# BOJ 14722 — 우유 도시 (w/ gpt-5.1-codex)  
(G4) <https://www.acmicpc.net/problem/14722>

## 문제 정보
N×N 격자(0:딸기, 1:초코, 2:바나나)에서 오른쪽/아래로만 이동하며 우유를 `0 → 1 → 2 → 0 ...` 순서로 최대 몇 잔 마실 수 있는지 구한다. `N ≤ 1000`.

---

## 사고흐름

1. 시간복잡도 계산
   1. 격자에서 오른쪽/아래로만 가면 총 이동 횟수 : 2 * (N-1)
   2. 각 스텝마다 둘 중 하나를 골라야하므로 총 경우의 수 : 2 ^ (2N-2)
   3. 즉 2^(2N) 수준이므로 DFS 완탐은 불가능 -> 격자 DP 필요
3. 마신 우유 개수의 `mod 3`가 다음에 마실 우유를 결정한다.
4. 이동이 오른쪽/아래만 허용되므로 `(i, j)`는 **위/왼쪽**에서만 갱신하면 된다.
5. 시간복잡도 `O(N^2)`, 추가 메모리 `O(N^2)`.

---

## 핵심아이디어

- `dp[i][j]`를 (i, j)까지 도달했을 때 마신 최대 잔 수로 두고, **현재 칸 우유 == dp[i][j] % 3**일 때 +1.
- 갱신은 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])` 후 조건을 확인.
- 시작 칸이 딸기(0)라면 `dp[0][0] = 1`로 초기화.

---

## 풀이 1 — DP 2차원 테이블 (내 제출)

### 전체 코드
```python
# 정답코드 DP

# N <= 1000 이므로 완탐은 불가하다는 거 생각해야했음

import sys
# sys.stdin = open("in.txt", "r")
input = sys.stdin.readline

N = int(input())
milk = [list(map(int, input().split())) for _ in range(N)]

dp = [[0]*N for _ in range(N)]

if milk[0][0] == 0:
    dp[0][0] = 1

for i in range(N):
    for j in range(N):
        # 왼쪽, 위 중 최댓값으로 DP 값 전이
        if i > 0:
            dp[i][j] = dp[i-1][j] # 직전 위 값을 현재 dp 로 전이
        if j > 0:
            dp[i][j] = max(dp[i][j], dp[i][j-1]) # 직전 왼쪽 값과 비교

        if milk[i][j] == dp[i][j] % 3: # 현재 마신우유갯수 % 3 이 이번에 마실 우유
            dp[i][j] += 1

print(dp[N-1][N-1])
```

### 로직 설명 + 코드

1) 위/왼쪽 최대값으로 현재 상태 채우기  
```python
for i in range(N):
    for j in range(N):
        if i > 0: # 위로부터 dp 값 전이
            dp[i][j] = dp[i-1][j] # 직전 위 값을 현재 dp 로 전이
        if j > 0: # 왼쪽으로부터 dp 값 전이
            dp[i][j] = max(dp[i][j], dp[i][j - 1]) # max(현재, 직전 왼쪽)

        if milk[i][j] == dp[i][j] % 3:  # 현재 마신우유갯수 % 3 이 이번에 마실 우유
            dp[i][j] += 1 # 마실 차례라면 +1
```
* 현재까지 마신 개수 `dp[i][j]`의 나머지가 이 칸 우유 종류와 같으면 한 잔 추가.

2) 답 출력  
```python
print(dp[N - 1][N - 1])
```
* 목적지까지 마신 최대 잔 수를 출력한다.

### 간단 시뮬레이션 예시 (3×3)

입력 격자 (0: 딸기, 1: 초코, 2: 바나나)
```
0 1 0
2 0 1
1 2 0
```

초기: (0,0)=0이 딸기이므로 `dp[0][0]=1` (딸기 1잔 마심).

1행 처리 (`i=0`): 위쪽이 없으니 왼쪽에서만 전이.
- (0,1): 왼쪽 dp=1, 현재 우유=1, `1 % 3 == 1`이므로 +1 → `dp=2` (딸기→초코).
- (0,2): 왼쪽 dp=2, 현재 우유=0, `2 % 3 == 0`이 아님 → `dp=2` 유지.

2행 처리 (`i=1`): 위/왼쪽 중 큰 값으로 채우고 조건 확인.
- (1,0): 위 dp=1, 현재 우유=2, `1 % 3 == 1`이라 불일치 → `dp=1`.
- (1,1): 위 dp=2, 왼쪽 dp=1 → 최대 2. 현재 우유=0, `2 % 3 == 2` 불일치 → `dp=2` 유지.
- (1,2): 위 dp=2, 왼쪽 dp=2 → 최대 2. 현재 우유=1, `2 % 3 == 2` 불일치 → `dp=2`.

3행 처리 (`i=2`):
- (2,0): 위 dp=1, 우유=1, `1 % 3 == 1` → +1 → `dp=2` (딸기→초코).
- (2,1): 위 dp=2, 왼쪽 dp=2 → 최대 2. 우유=2, `2 % 3 == 2` → +1 → `dp=3` (딸기→초코→바나나).
- (2,2): 위 dp=2, 왼쪽 dp=3 → 최대 3. 우유=0, `3 % 3 == 0` → +1 → `dp=4`.

결과: `dp[2][2]=4`로, 딸기→초코→바나나→딸기 순서로 총 4잔을 마시는 최적 경로가 존재함을 확인할 수 있다.

### 장단점

* 장점: `O(N^2)`로 제한 내에서 안정, 구현이 간단하다.
* 단점/개선 여지: 메모리 `O(N^2)`; 필요하다면 1행 롤링 배열로 `O(N)`까지 줄일 수 있다.

---

## 풀이 2 — 1차원 롤링 DP (AI 제안)

### 전체 코드
```python
import sys

input = sys.stdin.readline

N = int(input())
milk = [list(map(int, input().split())) for _ in range(N)]

dp = [0] * N

if milk[0][0] == 0:
    dp[0] = 1

for i in range(N):
    for j in range(N):
        if i == 0 and j == 0:
            continue
        top = dp[j]
        left = dp[j - 1] if j > 0 else 0
        dp[j] = max(top, left)
        if milk[i][j] == dp[j] % 3:
            dp[j] += 1

print(dp[N - 1])
```

### 로직 설명 + 코드

* 각 행을 돌며 `dp[j]`를 “현재 행의 (i, j)까지”로 사용한다.
```python
for i in range(N):
    for j in range(N):
        if i == 0 and j == 0:
            continue
        top = dp[j]        # 이전 행 값
        left = dp[j - 1] if j > 0 else 0
        dp[j] = max(top, left)
        if milk[i][j] == dp[j] % 3:
            dp[j] += 1

print(dp[N - 1])
```
* 위/왼쪽 최대값을 롤링하며, 조건이 맞을 때만 +1.

### 장단점

* 장점: 공간을 `O(N)`으로 줄인다.
* 단점: 가독성이 2D DP보다 조금 떨어질 수 있다.

---

## 비슷한 문제에서의 사고과정

* **격자 경로 + 상태 조건**: 이동 방향이 제한되면 위/왼쪽(또는 위/왼쪽/대각)에서만 전이하는 DP를 우선 고려.
* **순환 패턴 조건**: “k번째마다 특정 상태”는 `count % cycle_len`으로 표현하면 간단히 체크 가능.
* **메모리 최적화**: 전이가 인접 행/열에만 의존하면 롤링 배열로 공간을 줄인다.
* **실수 포인트**: 나머지(`% 3`)를 현재 칸에서 갱신하기 전에 먼저 위/왼쪽 최댓값으로 채우지 않으면 이전 경로가 무시될 수 있음.

---

## 정리 요약

* `dp[i][j]`를 최대 잔 수로 두고, 현재 칸 우유가 `dp % 3`과 같을 때만 +1 한다.
* 이동이 오른쪽/아래로 제한되므로 위/왼쪽에서 온 값만 사용해 `O(N^2)`에 해결.
* 순환 조건이 있는 격자 경로는 나머지 연산으로 상태를 표현하는 패턴을 재사용할 수 있다.
