# BOJ 14940 — 쉬운 최단거리 (w/ gpt-5.1-codex)  
<https://www.acmicpc.net/problem/14940>

## 문제 정보
격자에서 시작점(값 2)으로부터 각 칸까지의 최단 거리를 출력한다. 이동은 상하좌우, 벽(0)은 통과 불가. 도달 불가능한 칸은 -1, 벽은 0을 출력한다. `N, M ≤ 1000`.

---

## 사고흐름

1. 단일 시작점에서 모든 칸 거리 → **시작점에서 BFS 한 번**이면 충분.
2. 도달 여부를 표현하려고 `dist`를 -1로 초기화하고, 시작점만 0으로 세팅.
3. 벽(0)은 큐에 넣지 않고, 출력 시에도 0으로 유지한다.
4. 시간복잡도 `O(NM)`, 공간 `O(NM)`.

---

## 핵심아이디어

- **역탐색이 아닌 정방향 BFS**: 시작점을 큐에 넣어 최단 거리 테이블을 채운다.
- **도달 여부를 dist가 -1인지로 구분**, 단 벽은 별도로 0을 유지.
- 네 방향 이동만 고려하면 된다.

---

## 풀이 1 — 단일 BFS (내 제출)

### 전체 코드
```python
import sys
from collections import deque

input = sys.stdin.readline

N, M = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(N)]

dist = [[-1] * M for _ in range(N)]
q = deque()

for i in range(N):
    for j in range(M):
        if board[i][j] == 2:
            dist[i][j] = 0
            q.append((i, j))

dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
while q:
    x, y = q.popleft()
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        if 0 <= nx < N and 0 <= ny < M:
            if board[nx][ny] == 0:
                continue
            if dist[nx][ny] == -1:
                dist[nx][ny] = dist[x][y] + 1
                q.append((nx, ny))

for i in range(N):
    for j in range(M):
        if board[i][j] == 0:
            dist[i][j] = 0
    print(*dist[i])
```

### 로직 설명 + 코드

1) 시작점 찾기 및 초기화  
```python
for i in range(N):
    for j in range(M):
        if board[i][j] == 2:
            dist[i][j] = 0
            q.append((i, j))
```
* 목표(값 2)를 시작점으로 설정하고 거리 0, 큐에 삽입.

2) BFS로 거리 채우기  
```python
dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
while q:
    x, y = q.popleft()
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        if 0 <= nx < N and 0 <= ny < M:
            if board[nx][ny] == 0:  # 벽
                continue
            if dist[nx][ny] == -1:
                dist[nx][ny] = dist[x][y] + 1
                q.append((nx, ny))
```
* 벽이 아니고 아직 미도달(-1)인 칸만 큐에 넣으면서 최단거리 증가.

3) 출력 시 벽 처리  
```python
for i in range(N):
    for j in range(M):
        if board[i][j] == 0:
            dist[i][j] = 0
    print(*dist[i])
```
* 벽은 0으로 덮어쓰고, 나머지는 계산된 거리(-1 포함)를 그대로 출력.

### 장단점

* 장점: 단순 BFS로 `O(NM)`에 해결, 구현이 짧다.
* 단점/개선 여지: dist와 board 두 배열을 따로 들고 있어 메모리 `O(NM)` 두 배지만 제한 내.

---

## 풀이 2 — dist를 board에 덮어쓰기 (AI 제안)

### 전체 코드
```python
import sys
from collections import deque

input = sys.stdin.readline

N, M = map(int, input().split())
grid = [list(map(int, input().split())) for _ in range(N)]
q = deque()

for i in range(N):
    for j in range(M):
        if grid[i][j] == 2:
            grid[i][j] = 0
            q.append((i, j))
        elif grid[i][j] == 1:
            grid[i][j] = -1  # 도달 전 표시

dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
while q:
    x, y = q.popleft()
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == -1:
            grid[nx][ny] = grid[x][y] + 1
            q.append((nx, ny))

for row in grid:
    print(*row)
```

### 로직 설명 + 코드

* 1을 -1로 바꿔 “미도달” 표시, BFS로 덮어쓰며 거리 기록.
* 어차피 도달할 수 없는 위치는 -1 이여야하므로, 애초에 1을 싹 다 -1로 바꿔버리는 아이디어

```python
dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
while q:
    x, y = q.popleft()
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == -1:
            grid[nx][ny] = grid[x][y] + 1
            q.append((nx, ny))

for row in grid:
    print(*row)
```
* 별도 dist 없이 기존 배열을 재사용해 메모리 절약.

### 장단점

* 장점: 추가 배열 없이 메모리 절약.
* 단점: 원본 보드를 덮어쓰므로 후처리가 필요하면 부적합.

---

## 비슷한 문제에서의 사고과정

* **단일 시작점 다대상 거리**: 시작점에서 BFS 한 번으로 최단거리 테이블 구성.
* **도달 여부 표시**: 방문하지 않은 칸을 -1 등 특별한 값으로 초기화하면 출력이 쉬워짐.
* **벽/장애물**은 탐색에서 건너뛰고, 출력 시에도 별도 처리.
* **실수 포인트**: 목표(2)를 찾지 못한 채 BFS를 돌면 큐가 비어 아무 것도 채우지 못하므로 시작점을 먼저 찾아 넣어야 한다.

---

## 정리 요약

* 목표(2)를 시작으로 BFS해 모든 칸의 최단거리를 구하고, 벽은 0, 미도달은 -1로 출력한다.
* dist 별도 사용 또는 보드 덮어쓰기 두 방식 모두 `O(NM)`에 해결 가능.
* 도달 여부를 -1로 관리하는 패턴은 다른 격자 BFS에서도 그대로 활용할 수 있다.
