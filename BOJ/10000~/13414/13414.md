# BOJ 13414 — 수강신청 (w/ gpt-5.1-codex)  
<https://www.acmicpc.net/problem/13414>

## 문제 정보
수강신청 클릭 로그 `L`개가 주어질 때, 같은 학번은 **마지막 클릭만 유효**하다. 유효한 클릭을 순서대로 정렬해 앞에서 `K`명만 출력한다. `K ≤ 100,000`, `L ≤ 500,000`.

1. 버튼 먼저 누른대로 대기 목록에 들어감
2. 이미 대기 중인 상태에서 다시 버튼 누를 경우에는 맨 뒤로 밀려남

---

## 사고흐름

1. 같은 학번의 마지막만 남기면 되므로 해시로 “마지막 등장 인덱스”를 덮어쓴다.
2. 남은 학번을 등장 인덱스 오름차순으로 정렬해 앞 `K`명을 출력하면 끝.
3. 정렬을 없애려면 등장 인덱스 범위(`0..L-1`)를 그대로 버킷 배열로 써서 `O(L)` 스캔 가능.
4. 시간복잡도: 해시 저장 `O(L)`, 정렬 시 `O(L log L)`; 버킷 사용 시 `O(L)`.

---

## 핵심아이디어

- **마지막 클릭만 덮어쓰기**: `last[sid] = idx`.
- 출력 순서는 **등장 인덱스 오름차순**이므로 정렬 또는 버킷 스캔으로 확보.
- 입력이 크므로 `sys.stdin.readline`으로 I/O 최소화.

---

## 풀이 1 — dict + 정렬 (내 제출)

### 전체 코드
```python
import sys

read = sys.stdin.readline

K, L = map(int, read().split())
order = {}

for idx in range(L):
    sid = read().strip()
    order[sid] = idx  # 마지막 클릭만 저장 (order[학번] = 인덱스)

items = sorted(order.items(), key=lambda x: x[1])

for sid, _ in items[:K]:
    print(sid)
```

### 로직 설명 + 코드

1) 마지막 클릭 저장  
```python
order[sid] = idx
```
* 같은 학번이 오면 인덱스를 덮어써 마지막 클릭만 남긴다.

2) 정렬 후 상위 K명 출력  
```python
items = sorted(order.items(), key=lambda x: x[1])
for sid, _ in items[:K]:
    print(sid)
```
* 등장 인덱스 기준으로 정렬한 뒤 앞에서 K명을 출력한다.

### 장단점

* 장점: 구현이 가장 단순하고 오류 여지가 적다.
* 단점: `O(L log L)` 정렬이 필요해 입력이 클 때 상수 시간 손해.

---

## 풀이 2 — 버킷 스캔으로 정렬 제거 (AI 제안)

### 전체 코드
```python
import sys

read = sys.stdin.readline

K, L = map(int, read().split())
last = {}
for i in range(L):
    sid = read().strip()
    last[sid] = i

bucket = [None] * L
for sid, idx in last.items():
    bucket[idx] = sid

count = 0
for sid in bucket:
    if sid is None:
        continue
    print(sid)
    count += 1
    if count == K:
        break
```

### 로직 설명 + 코드

* `last`로 마지막 인덱스를 저장한 뒤, 등장 인덱스 크기(`L`)만큼 버킷 배열을 만들어 정렬 없이 순서 복원.
* 버킷을 앞에서부터 스캔하며 `K`명 출력하면 끝이다.
* 원본 dict(`last`) 의 key, value 를 뒤집은 bucket 배열이 핵심

### 장단점

* 장점: 정렬을 제거해 `O(L)`에 해결, 상수 시간도 작다.
* 단점: 버킷 배열이 `O(L)` 메모리를 사용하며, `L`이 매우 클 때 메모리 여유를 확인해야 한다.

---

## 비슷한 문제에서의 사고과정

* **“마지막 이벤트만 유효”**: 해시에 마지막 위치를 덮어쓰고, 필요하면 위치 기준 정렬/스캔.
* **정렬 제거 패턴**: 키가 범위 내 정수라면 버킷/카운팅 방식으로 `O(N)` 복원 가능.
* **실수 포인트**: 중복을 리스트에서 제거하려고 매번 `in` 탐색하면 `O(N^2)`로 TLE; 마지막 위치를 덮어쓰는 해시가 핵심.

---

## 정리 요약

* 학번별 마지막 클릭만 남기고 등장 순서대로 앞 `K`명을 출력하면 된다.
* 기본은 dict + 정렬(`O(L log L)`), 범위가 명확할 때는 버킷 스캔으로 `O(L)`까지 줄일 수 있다.
