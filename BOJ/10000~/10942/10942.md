# BOJ 10942 — 팰린드롬? (w/ gpt-5.2-codex)
(G4) <https://www.acmicpc.net/problem/10942>

## 문제 정보
자연수 수열이 주어지고, M개의 구간 질문 (S, E)에 대해 S~E 구간이 팰린드롬인지 판별한다.  
제약: `N ≤ 2000`, `M ≤ 1,000,000`. 질의마다 선형 확인은 불가하므로 **전처리 + O(1) 질의**가 필요하다.
---

## 사고흐름
1. 질의가 매우 많음 → 구간 판정을 매번 수행하면 TLE → **모든 구간을 미리 계산하는 DP**가 적합.
2. 팰린드롬 점화식: `arr[s] == arr[e]` 이고 `dp[s+1][e-1]`이면 팰린드롬.
3. 길이 1, 2를 먼저 채운 뒤 길이를 늘려가며 DP를 확장.
4. 전처리 `O(N^2)`, 질의 `O(1)` → 전체 `O(N^2 + M)`로 제한 내.
5. `M`이 크므로 **빠른 입력**과 **버퍼 출력** 필수.
---

## 핵심아이디어
**모든 구간 팰린드롬 여부를 DP 테이블에 저장**하고, 질의는 즉시 조회한다.  
길이를 짧은 것부터 채우면 `dp[s+1][e-1]`가 항상 선계산되어 점화식이 안전하게 적용된다.
---

## 풀이

### 풀이 1 — 길이 기준 DP (내 코드)

```python
import sys
read = sys.stdin.readline

def solution():
    N = int(read())
    nums = [0] + list(map(int, read().split()))
    M = int(read())
    queries = [list(map(int, read().split())) for _ in range(M)]

    dp = [[False]*(N+1) for _ in range(N+1)]

    for i in range(1, N+1):
        dp[i][i] = True
    
    for j in range(1, N):
        if nums[j] == nums[j+1]:
            dp[j][j+1] = True

    length = 0

    for length in range(3, len(nums)+1): # 길이
        for start in range(1, N-length+2): # N = 5, length = 3
            end = start + length - 1
            if nums[start] == nums[end] and dp[start+1][end-1]:
                dp[start][end] = True

    # for row in dp:
    #     print(row)

    for query in queries:
        if dp[query[0]][query[1]]:
            print(1)
        else:
            print(0)


if __name__ == "__main__":
    solution()
```

#### 핵심 포인트
- 길이 1/2를 먼저 채운 뒤, 길이 3 이상을 순차 계산한다.
- `dp[s][e]`는 `dp[s+1][e-1]`에 의존하므로 **길이 증가 순**이 안전하다.
- 질의 응답은 DP 조회만 수행한다.

#### 로직 설명 (중요 부분)
길이 3 이상에 대해 내부 구간이 팰린드롬인지 확인한다.

```python
for length in range(3, len(nums)+1):
    for start in range(1, N-length+2):
        end = start + length - 1
        if nums[start] == nums[end] and dp[start+1][end-1]:
            dp[start][end] = True
```

#### 피드백
- 점화식과 전처리 순서는 정확하다.
- 다만 질의가 최대 1,000,000이므로 `queries`를 모두 저장하지 않고 **입력 즉시 출력 버퍼에 누적**하는 편이 메모리와 속도 면에서 더 안정적이다.
- `range(3, len(nums)+1)`는 동작은 하지만 의미상 `range(3, N+1)`이 더 명확하다.

#### 장단점
- 장점: 구현이 직관적이고, 전처리 `O(N^2)` + 질의 `O(1)`로 안정적.
- 단점: 질의 리스트를 전부 저장하고 `print`를 반복하면 큰 M에서 느려질 수 있음.

---

### 풀이 1.2 — 길이 기준 DP (Java, 내 코드)

```java
import java.io.*;
import java.util.StringTokenizer;

class Main {
	// 입출력 담당 main
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine().trim());
		int[] arr = new int[n + 1];
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 1; i <= n; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}

		int m = Integer.parseInt(br.readLine().trim());
		int[][] queries = new int[m][2];
		for (int i = 0; i < m; i++) {
			st = new StringTokenizer(br.readLine());
			queries[i][0] = Integer.parseInt(st.nextToken());
			queries[i][1] = Integer.parseInt(st.nextToken());
		}
		String result = solution(n, arr, queries);

		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		bw.write(result);
		bw.flush();
	}

	public static String solution(int n, int[] arr, int[][] queries) {
		// dp[s][e] = s~e 구간이 팰린드롬이면 true
		boolean[][] dp = new boolean[n + 1][n + 1];
		// 길이 1은 항상 팰린드롬
		for (int i = 1; i <= n; i++) {
			dp[i][i] = true;
		}
		// 길이 2는 두 값이 같을 때만 팰린드롬
		for (int i = 1; i + 1 <= n; i++) {
			if (arr[i] == arr[i + 1]) {
				dp[i][i + 1] = true;
			}
		}
		// 길이 3 이상은 양 끝이 같고 내부가 팰린드롬이면 성립
		for (int len = 3; len <= n; len++) {
			for (int s = 1; s + len - 1 <= n; s++) {
				int e = s + len - 1;
				if (arr[s] == arr[e] && dp[s + 1][e - 1]) {
					dp[s][e] = true;
				}
			}
		}

		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < queries.length; i++) {
			int s = queries[i][0];
			int e = queries[i][1];
			sb.append(dp[s][e] ? 1 : 0).append('\n');
		}
		return sb.toString();
	}
}
```

#### 핵심 포인트
- 파이썬 풀이와 동일한 길이 기반 DP 점화식을 사용한다.
- 질의를 모두 저장한 뒤 `StringBuilder`로 한 번에 출력한다.

#### 로직 설명 (중요 부분)
길이 3 이상은 내부 구간이 팰린드롬일 때만 성립한다.

```java
for (int len = 3; len <= n; len++) {
	for (int s = 1; s + len - 1 <= n; s++) {
		int e = s + len - 1;
		if (arr[s] == arr[e] && dp[s + 1][e - 1]) {
			dp[s][e] = true;
		}
	}
}
```

#### 피드백
- 점화식과 전처리 순서가 정확하다.
- 다만 `queries` 배열에 전부 저장하는 방식은 메모리 사용이 늘어난다.  
  입력 즉시 `StringBuilder`에 누적하는 방식이 더 간결하고 빠를 수 있다.

#### 장단점
- 장점: 구현이 단순하고 자바 기준 입출력도 안정적이다.
- 단점: 질의를 전부 보관하는 방식은 M이 클 때 불필요한 메모리를 사용한다.

---

### 풀이 1.1 — 같은 로직, 입력/출력 리팩터링

```python
import sys

read = sys.stdin.readline
write = sys.stdout.write

def solution():
    n = int(read())
    nums = [0] + list(map(int, read().split()))

    dp = [[False] * (n + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        dp[i][i] = True
    for i in range(1, n):
        if nums[i] == nums[i + 1]:
            dp[i][i + 1] = True
    for length in range(3, n + 1):
        for start in range(1, n - length + 2):
            end = start + length - 1
            if nums[start] == nums[end] and dp[start + 1][end - 1]:
                dp[start][end] = True

    m = int(read())
    out = []
    for _ in range(m):
        s, e = map(int, read().split())
        out.append("1\n" if dp[s][e] else "0\n")
    write("".join(out))

if __name__ == "__main__":
    solution()
```

#### 핵심 포인트
- 로직은 동일하지만 **질의를 즉시 처리**하고 출력은 버퍼로 모은다.
- 길이 반복을 `range(3, n + 1)`로 명확화했다.

#### 로직 설명 (중요 부분)
질의는 DP 조회만 수행하고 결과를 버퍼에 누적한다.

```python
for _ in range(m):
    s, e = map(int, read().split())
    out.append("1\n" if dp[s][e] else "0\n")
```

#### 장단점
- 장점: 메모리 사용량 감소, 출력 속도 개선.
- 단점: 알고리즘 구조 자체는 풀이 1과 동일.

---

### 풀이 2 — 중심 확장 방식으로 DP 채우기

```python
import sys

read = sys.stdin.readline
write = sys.stdout.write

def solution():
    n = int(read())
    a = [0] + list(map(int, read().split()))

    pal = [[False] * (n + 1) for _ in range(n + 1)]

    # 홀수 길이 중심 확장
    for center in range(1, n + 1):
        l = r = center
        while l >= 1 and r <= n and a[l] == a[r]:
            pal[l][r] = True
            l -= 1
            r += 1

    # 짝수 길이 중심 확장
    for center in range(1, n):
        l, r = center, center + 1
        while l >= 1 and r <= n and a[l] == a[r]:
            pal[l][r] = True
            l -= 1
            r += 1

    m = int(read())
    out = []
    for _ in range(m):
        s, e = map(int, read().split())
        out.append("1\n" if pal[s][e] else "0\n")
    write("".join(out))

if __name__ == "__main__":
    solution()
```

#### 핵심 포인트
- 길이 기준 DP 대신 **중심 확장**으로 모든 구간을 채운다.
- 홀수/짝수 중심을 분리해 `O(N^2)`에 모든 팰린드롬 구간을 구한다.

#### 로직 설명 (중요 부분)
중심을 고정하고 좌우로 확장하며 팰린드롬 여부를 채운다.

```python
for center in range(1, n + 1):
    l = r = center
    while l >= 1 and r <= n and a[l] == a[r]:
        pal[l][r] = True
        l -= 1
        r += 1
```

#### 장단점
- 장점: 점화식 없이도 직관적으로 모든 구간을 채울 수 있음.
- 단점: DP 방식에 익숙하면 오히려 덜 명확할 수 있음.

---

### 풀이 3 — 모범 풀이 (Manacher + O(1) 질의)

```python
import sys

read = sys.stdin.readline
write = sys.stdout.write

def manacher(nums):
    n = len(nums)
    d1 = [0] * n  # 홀수 길이: center i, 길이 = 2*d1[i]-1
    l = 0
    r = -1
    for i in range(n):
        k = 1 if i > r else min(d1[l + r - i], r - i + 1)
        while i - k >= 0 and i + k < n and nums[i - k] == nums[i + k]:
            k += 1
        d1[i] = k
        if i + k - 1 > r:
            l = i - k + 1
            r = i + k - 1

    d2 = [0] * n  # 짝수 길이: center between i-1 and i, 길이 = 2*d2[i]
    l = 0
    r = -1
    for i in range(n):
        k = 0 if i > r else min(d2[l + r - i + 1], r - i + 1)
        while i - k - 1 >= 0 and i + k < n and nums[i - k - 1] == nums[i + k]:
            k += 1
        d2[i] = k
        if i + k - 1 > r:
            l = i - k
            r = i + k - 1
    return d1, d2

def is_pal(d1, d2, l, r):
    length = r - l + 1
    if length % 2 == 1:
        center = (l + r) // 2
        return d1[center] >= length // 2 + 1
    center = (l + r + 1) // 2
    return d2[center] >= length // 2

def solution():
    n = int(read())
    arr = list(map(int, read().split()))
    d1, d2 = manacher(arr)

    m = int(read())
    out = []
    for _ in range(m):
        s, e = map(int, read().split())
        l = s - 1
        r = e - 1
        out.append("1\n" if is_pal(d1, d2, l, r) else "0\n")
    write("".join(out))

if __name__ == "__main__":
    solution()
```

#### 핵심 포인트
- Manacher로 **모든 중심의 최대 팰린드롬 반경**을 `O(N)`에 계산.
- 각 질의는 **중심 위치와 반경 비교만으로 O(1)** 처리.

#### 로직 설명 (중요 부분)
홀수/짝수 길이 반경 배열을 이용해 질의를 상수 시간에 판정한다.

```python
def is_pal(d1, d2, l, r):
    length = r - l + 1
    if length % 2 == 1:
        center = (l + r) // 2
        return d1[center] >= length // 2 + 1
    center = (l + r + 1) // 2
    return d2[center] >= length // 2
```

#### 장단점
- 장점: 전처리 `O(N)`, 질의 `O(1)`로 이론상 가장 빠름.
- 단점: 구현 난이도가 DP보다 높고, 인덱스 변환 실수가 잦음.

---

## 비슷한 문제에서의 사고과정
- 구간 질의가 많으면 **전처리 후 O(1) 질의** 구조를 우선 고려한다.
- 팰린드롬은 **양 끝 비교 + 내부 구간 참조**가 핵심이므로 DP 점화식이 자연스럽다.
- 자주 하는 실수/오해 포인트:
  - 길이 2 초기화를 빼먹어 DP가 전파되지 않음.
  - `s+1`, `e-1` 경계 조건을 잘못 처리함.
  - `print` 반복으로 대량 출력이 느려지는 문제.
---

## 정리 요약
팰린드롬 구간 질의는 **전처리(DP 또는 Manacher) + O(1) 질의**가 정석이다.  
길이 증가 순 DP는 구현이 단순하고 안정적이며, 출력 버퍼링이 성능의 핵심 포인트다.
---
