# BOJ 11286 — 절댓값 힙 (w/ chatgpt)

## 문제 정보
절댓값 기준으로 정렬되는 특수한 우선순위 큐(힙)를 구현하는 문제.  
연산은 다음 두 가지만 존재함.

1. 정수 `x (x ≠ 0)`를 배열(힙)에 추가
2. `x = 0`일 때:  
   - 배열에서 **절댓값이 가장 작은 값**을 출력하고 제거  
   - 절댓값이 가장 작은 값이 여러 개면, **실제 값이 가장 작은 수** 출력  
   - 배열이 비어 있으면 `0` 출력

---

## 사고흐름

1. 필요한 자료구조 판단  
   - “가장 작은” 값을 반복적으로 꺼낸다 → 전형적인 **우선순위 큐(힙)** 문제.  
   - 여기서는 절댓값 기준 + tie-breaking(실제 값 기준)까지 요구하므로 **커스텀 우선순위 큐** 필요.

2. 우선순위 기준 정의  
   - 기본 힙은 “작은 값이 우선”이라는 기준만 있음.  
   - 문제의 정렬 기준:
     1. 절댓값이 작은 순
     2. 절댓값이 같으면 실제 값이 작은 순
   - 파이썬 `heapq`는 비교 함수를 받지 않고, **값 자체를 우선순위가 드러나게 구성**해야 함 → `(우선순위1, 우선순위2, 실제값, ...)` 형태의 튜플 사용.

3. 동작 방식 구체화  
   - `x ≠ 0` → `heappush(heap, (abs(x), x))`
   - `x = 0`
     - 힙이 비어 있으면 `0` 출력
     - 비어 있지 않으면 `heappop(heap)` 후, 튜플의 두 번째 요소(`x`) 출력

4. 시간복잡도  
   - 연산 개수 `N ≤ 100,000`
   - 각 `push`, `pop` 연산: `O(log N)`
   - 전체 시간복잡도: `O(N log N)` → 파이썬으로 충분히 해결 가능.

5. 입출력 최적화  
   - `sys.stdin.readline` 사용  
   - 출력은 바로바로 `print` 하는 방식으로도 충분함.

---

## 핵심아이디어

- 단일 힙에 `(abs(x), x)` 형태로 저장해서 **정렬 기준을 튜플에 인코딩**하는 것이 포인트.
- 파이썬 `heapq`는 최소 힙이므로, 첫 번째 원소 `abs(x)`가 작을수록, 같으면 두 번째 원소 `x`가 작을수록 우선순위가 높아짐.
- 별도의 compare 함수가 없기 때문에:
  - “원하는 우선순위로 정렬되도록 데이터 구조를 설계함”이 핵심.

---

## 풀이 1 — 단일 힙 + 튜플 기반 우선순위

```python
import sys
import heapq as hq
# sys.stdin = open("in.txt", "r")
read = sys.stdin.readline

heap = []

n = int(read())
nums = []
for _ in range(n):
    nums.append(int(read()))

for num in nums:
    if num:
        hq.heappush(heap, (abs(num), num))
    else:
        if heap:
            print(hq.heappop(heap)[1])
        else:
            print(0)
```

### 핵심 포인트

* 힙에 `(abs(num), num)` 형태로 저장해서 **절댓값 → 실제값** 순으로 정렬되도록 만듦.
* `num != 0`일 때 `heappush`, `num == 0`일 때 `heappop` 사용.
* 힙이 비어 있을 때 `0` 출력하는 예외 처리 필수.

### 로직 설명 (중요부분만)

예제 입력 일부만 가지고 흐름을 살펴보면:

```text
입력:
1
-1
0
0
0
...
```

1. `1` 입력

   * `heap.push((1, 1))`
   * 힙 상태: `[(1, 1)]`

2. `-1` 입력

   * `heap.push((1, -1))`
   * 힙 내부 정렬:

     * `(1, -1)` vs `(1, 1)` 비교 → 첫 번째 원소(1)는 같음, 두 번째 원소(-1 vs 1) 비교 → `-1`이 더 작음
   * 힙 상태: `[(1, -1), (1, 1)]`

3. `0` 입력 → 출력 요청

   * `heappop()` → `(1, -1)` 꺼냄 → 실제 값 `-1` 출력
   * 힙 상태: `[(1, 1)]`

4. 다음 `0` 입력

   * `heappop()` → `(1, 1)` 꺼냄 → `1` 출력
   * 힙 상태: `[]`

5. 다음 `0` 입력

   * 힙이 비어있으므로 `0` 출력

이 원리가 전체 입력에 대해 반복되며, 항상 문제에서 요구하는 순서대로 값이 빠져나오게 됨.

### 장단점

* 장점

  * 구현이 매우 간단하고 직관적임.
  * 튜플 기반 우선순위 정의는 파이썬 우선순위 큐 커스텀의 대표 패턴이라 재사용성 높음.
  * 시간복잡도 `O(N log N)`으로 충분히 효율적.

* 단점

  * 값을 한 번 `nums`에 모은 뒤 다시 처리하고 있어, 메모리 사용이 약간 비효율적임.

    * 입력을 받으면서 바로 처리해도 됨.
  * 힙에 튜플을 넣는다는 개념이 익숙하지 않으면 처음에는 다소 낯설 수 있음.

---

## 풀이 2 — 입력 즉시 처리 + 동일 아이디어 (리팩토링)

```python
import sys
import heapq as hq
# sys.stdin = open("in.txt", "r")
read = sys.stdin.readline

n = int(read())
heap = []

for _ in range(n):
    x = int(read())
    if x != 0:
        # (절댓값, 실제 값) 을 우선순위 튜플로 사용
        hq.heappush(heap, (abs(x), x))
    else:
        if heap:
            print(hq.heappop(heap)[1])
        else:
            print(0)
```

### 핵심 포인트

* 풀이 1과 알고리즘은 동일함.
* 입력을 **배열에 따로 저장하지 않고**, 바로바로 처리하는 방식으로 리팩토링.
* 메모리 절약 + 불필요한 리스트 순회 제거.

### 로직 설명 (중요부분만)

* `x != 0`: 바로 `heappush((abs(x), x))`
* `x == 0`:

  * 힙이 비어있으면 `0`
  * 비어있지 않으면 `heappop()` 결과의 두 번째 요소(`x`) 출력
* 문제의 조건을 그대로 스트림 형태로 처리하는 구조라 흐름이 더 자연스러움.

### 장단점

* 장점

  * 입력과 처리가 한 번에 이뤄져 구조가 깔끔함.
  * 메모리 사용량 감소.
* 단점

  * 알고리즘 구조 자체는 풀이 1과 동일하므로, 사고 과정 측면에서 추가적인 이득은 거의 없음.

---

## 비슷한 문제에서의 사고과정

1. “가장 작은/큰 값”을 반복적으로 꺼내는 문제

   * 기본 접근: **힙(우선순위 큐)** 고려.
   * 파이썬에서는 `heapq` 모듈 사용.

2. 우선순위 기준이 단순하지 않을 때

   * 비교 함수를 직접 넘길 수 없으므로 (python sort 와 다르게 lambda 익명함수 방식이 불가능해서 미리 전처리를 한 값을 튜플에 넣어야함)

     * **튜플**에 우선순위를 담아서 해결:

       * 예: 절댓값 기준 → `(abs(x), x)`
       * 예: 내림차순 → `(-value, value)` 또는 `heapq.nlargest` 등
       * 예: (우선순위, 시간, 값) → `(priority, timestamp, value)`

3. 파이썬 우선순위 큐 커스텀 정리

   * 기본 사용법:

     ```python
     import heapq

     heap = []
     heapq.heappush(heap, value)
     smallest = heapq.heappop(heap)
     ```

   * 커스텀 정렬 기준(튜플):

     ```python
     # 1. 첫 번째 기준: a 오름차순
     # 2. 두 번째 기준: b 오름차순
     heapq.heappush(heap, (a, b, original_value))
     ```

   * 절댓값 힙 패턴:

     ```python
     heapq.heappush(heap, (abs(x), x))
     ```

   * “실제 값이 큰 걸 먼저 꺼내고 싶다” 같은 경우:

     ```python
     # value 내림차순
     heapq.heappush(heap, (-value, value))
     ```

4. 다른 커스텀 방법(참고)

   * 객체에 `__lt__`(less than) 메서드를 정의해서 쓸 수도 있음.
     다만 실전 코테에서는 튜플 방식이 더 간단하고 빠르게 쓸 수 있음.

   ```python
   class Node:
       def __init__(self, x):
           self.x = x

       def __lt__(self, other):
           # 절댓값 기준, 같으면 실제 값 기준
           if abs(self.x) == abs(other.x):
               return self.x < other.x
           return abs(self.x) < abs(other.x)

   heap = []
   heapq.heappush(heap, Node(x))
   node = heapq.heappop(heap)
   print(node.x)
   ```

   * 구조는 명확하지만, 객체 정의가 필요해서 코딩테스트에서는 잘 안 쓰는 편.

---

## 정리 요약

* BOJ 11286은 “**절댓값 + 실제 값**”이라는 두 단계 우선순위를 가지는 **우선순위 큐 구현 문제**임.
* 파이썬 `heapq`는 비교 함수 대신 **튜플을 활용한 우선순위 인코딩**으로 커스텀하는 것이 핵심.

  * `(abs(x), x)`를 힙에 넣으면, 절댓값이 작은 순 → 값이 작은 순으로 자동 정렬됨.
* 전체 연산 수 `N ≤ 100,000`에서 `O(N log N)` 으로 해결 가능.
* 비슷한 문제에서:

  * “어떤 기준으로 정렬해야 하는가?”를 튜플의 순서로 옮기고,
  * 우선순위 큐를 사용하는 패턴을 그대로 재사용하면 됨.
