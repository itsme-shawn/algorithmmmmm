# BOJ 11659 — 구간 합 구하기 4 (w/ gpt-5.1-codex)  
(S3) - <https://www.acmicpc.net/problem/11659>

## 문제 정보
길이 `N`(≤100,000) 배열이 주어지고, `M`(≤100,000) 번의 구간 합 질의 `i, j`에 대해 `A[i…j]` 합을 출력한다.

---

## 사고흐름
1. 각 질의를 매번 합산하면 `O(MN)`으로 시간 초과가 난다.
2. **Prefix Sum**을 쓰면 한 번의 전처리 `O(N)` 후 각 질의를 `O(1)`로 답할 수 있다.
3. `prefix[k] = A[0] + … + A[k-1]`, 구간 합은 `prefix[j] - prefix[i-1]`.

---

## 핵심아이디어
- **누적합 배열**을 만들어 두면 임의 구간 합을 뺄셈 한 번으로 계산할 수 있다.
- 입력 크기와 질의 수가 모두 1e5라, `O(N+M)` 해법이 필요하다.

---

## 풀이 1 — 단순 합산 (내 제출 원본, TLE)

### 전체 코드
```python
import sys

read = sys.stdin.readline

def solution():
    n, m = map(int, read().split())
    nums = list(map(int, read().split()))
    for _ in range(m):
        i, j = map(int, read().split())
        print(sum(nums[i-1:j]))


if __name__ == "__main__":
    solution()
```

### 로직 설명
- 매 질의마다 `sum(nums[i-1:j])`로 구간을 직접 더한다.

### 피드백
- 질의당 최대 `O(N)`이라 `M=1e5`에서 시간 초과가 발생한다.
- 동일 로직을 유지하면서 **누적합**을 사전 계산하도록 수정해야 한다.

---

## 풀이 1.1 — 누적합으로 최적화 (AI 첨삭, accepted)
```python
import sys

read = sys.stdin.readline

def solution():
    n, m = map(int, read().split())
    nums = list(map(int, read().split()))

    prefix = [0] * (n + 1)
    for idx, num in enumerate(nums, 1):
        prefix[idx] = prefix[idx - 1] + num

    out = []
    for _ in range(m):
        i, j = map(int, read().split())
        out.append(str(prefix[j] - prefix[i - 1]))

    sys.stdout.write("\n".join(out))


if __name__ == "__main__":
    solution()
```
- 누적합 `prefix`를 만들어 두고, 각 질의를 `prefix[j]-prefix[i-1]`로 `O(1)`에 처리한다.
- 출력도 버퍼(`out` 리스트)로 모아 한 번에 써서 입출력 오버헤드를 줄였다.

---

## 풀이 2 — itertools.accumulate 활용 (AI 제안)
```python
import sys
from itertools import accumulate

read = sys.stdin.readline

n, m = map(int, read().split())
nums = list(map(int, read().split()))
prefix = [0] + list(accumulate(nums))

out = []
for _ in range(m):
    i, j = map(int, read().split())
    out.append(str(prefix[j] - prefix[i - 1]))

sys.stdout.write("\n".join(out))
```
- 표준 라이브러리 `accumulate`로 누적합을 생성해 코드 길이를 줄였다.
- 시간·공간 복잡도는 풀이 1.1과 동일하다.

---

## 비슷한 문제에서의 사고과정
- 구간 합/평균/갯수 질의가 많다면 **Prefix Sum**을 우선 고려한다.
- 업데이트가 없는 정적 배열은 누적합이 최적이고, 업데이트가 있으면 Fenwick/세그먼트 트리를 생각한다.
- 질의·입력 크기가 1e5 이상이면 `O(log N)` 또는 `O(1)` 질의가 필요하다.

---

## 정리 요약
- 질의당 직접 합산은 `O(MN)`으로 불가능하니 누적합으로 `O(1)` 질의 응답을 만든다.
- `prefix[j] - prefix[i-1]` 패턴을 기억해 두면 구간 합 문제를 빠르게 해결할 수 있다.
