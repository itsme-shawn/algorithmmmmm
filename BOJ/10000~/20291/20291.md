# BOJ 20291 — 파일 정리 (w/ gpt-5.1-codex)  
(S3) - <https://www.acmicpc.net/problem/20291>

## 문제 정보
`이름.확장자` 형태의 파일 N개가 주어진다. 확장자별 개수를 세어 확장자 사전순으로 출력한다. `N ≤ 50,000`.

---

## 사고흐름

1. 파일명을 `split(".", 1)`으로 나눠 확장자를 얻는다.
2. 해시에 개수를 누적한다.
3. 확장자를 키로 사전순 정렬해 출력한다. 시간복잡도는 정렬 `O(N log N)`이 지배.

---

## 핵심아이디어

- **확장자만 카운트**하면 되므로 `dict[ext] += 1`.
- 출력 순서만 정렬, 입력 순서는 중요하지 않다.

---

## 풀이 1 — 해시 카운트 (내 제출)

### 전체 코드
```python
import sys

input = sys.stdin.readline

n = int(input())
count = {}

for _ in range(n):
    name, ext = input().strip().split(".", 1)
    count[ext] = count.get(ext, 0) + 1

for ext, cnt in sorted(count.items()):
    print(ext, cnt)
```

### 로직 설명 + 코드

1) 확장자 추출 및 카운트  
```python
for _ in range(n):
    name, ext = input().strip().split(".", 1)
    count[ext] = count.get(ext, 0) + 1
```
* `split(".", 1)`로 앞부분에 점이 있어도 안전하게 확장자만 취한다.

2) 사전순 출력  
```python
for ext, cnt in sorted(count.items()):
    print(ext, cnt)
```
* 키 기준 정렬만 해주면 요구 순서를 만족한다.

### 장단점

* 장점: 구현이 짧고 `O(N log N)` 정렬 외 추가 비용이 없다.
* 단점/개선 여지: 없다; 입력 크기에서 충분히 빠르다.

---

## 풀이 2 — `Counter` 활용 (AI 제안)

### 전체 코드
```python
import sys
from collections import Counter

input = sys.stdin.readline

n = int(input())
exts = []
for _ in range(n):
    _, ext = input().strip().split(".", 1)
    exts.append(ext)

for ext, cnt in sorted(Counter(exts).items()):
    print(ext, cnt)
```

### 로직 설명 + 코드

* 표준 라이브러리 `Counter`로 카운트를 맡기고, 나머지는 동일하게 정렬 출력.

### 장단점

* 장점: 코드가 더 짧고 의도가 명확.
* 단점: 리스트에 한 번 담는 추가 메모리가 든다.

---

## 비슷한 문제에서의 사고과정

* **문자열 그룹 카운트**: 키 추출 → 해시 누적 → 키 정렬 출력.
* **특수 구분자**: 구분자가 여러 번 나올 수 있으면 `split(delim, 1)`로 안전하게 나눈다.
* **실수 포인트**: 파일명에 점이 여러 개 있을 때 `split(".")`로 나누면 확장자가 잘못 분리될 수 있으니 `maxsplit=1`을 쓰는 것이 안전하다.

---

## 정리 요약

* 파일명을 구분자 `.`로 나눠 확장자별로 카운트하고, 사전순으로 출력하면 끝.
* `dict` 또는 `Counter` 모두 적합하며 정렬 비용 `O(N log N)`이 핵심이다.
