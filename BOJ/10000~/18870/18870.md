# BOJ 18870 — 좌표 압축 (w/ gpt-5.1-codex)  
(S2) - <https://www.acmicpc.net/problem/18870>

## 문제 정보
좌표 `N`개가 주어질 때, 각 좌표보다 작은 서로 다른 좌표의 개수를 압축 좌표로 출력한다. 동일 좌표는 같은 압축 값을 가진다. `N ≤ 1,000,000`, 좌표 값 범위는 ±1e9.

---

## 사고흐름

1. 같은 값은 같은 순위를 가져야 하므로 **중복 제거 후 정렬**이 필요하다.
2. 정렬된 리스트의 인덱스를 압축 값으로 사용해 딕셔너리에 매핑한다.
3. 원본 순서로 순회하며 매핑 값을 출력하면 끝. 시간은 정렬 `O(N log N)`이 지배.

---

## 핵심아이디어

- `uniq = sorted(set(nums))`로 유니크 값만 정렬.
- `rank[val] = idx`로 값→압축값을 해시에 저장해 O(1) 조회.
- 출력은 입력 순서대로 `rank[x]`를 꺼낸다.

---

## 풀이 1 — 정렬 + 딕셔너리 매핑 (내 제출)

### 전체 코드
```python
import sys

input = sys.stdin.readline

N = int(input())
nums = list(map(int, input().split()))

uniq = sorted(set(nums))
rank = {v: i for i, v in enumerate(uniq)}

out = (str(rank[x]) for x in nums)
sys.stdout.write(" ".join(out))
```

### 로직 설명 + 코드

1) 중복 제거 후 정렬  
```python
uniq = sorted(set(nums))
```
* 동일 좌표를 하나로 묶고 오름차순 인덱스를 압축값으로 쓴다.

2) 매핑 생성  
```python
rank = {v: i for i, v in enumerate(uniq)}
```
* 값→압축값 조회를 O(1)로 만든다.

3) 원본 순서 출력  
```python
out = (str(rank[x]) for x in nums)
sys.stdout.write(" ".join(out))
```
* 입력 순서대로 매핑 값을 출력한다.

### 장단점

* 장점: 구현이 단순하고 `O(N log N)` 정렬만 부담.
* 단점/개선 여지: 좌표 범위가 작을 때는 카운팅/버킷으로 `O(N)` 가능하지만 이 문제 범위에서는 정렬이 현실적.

---

## 풀이 2 — C++ set + 해시 매핑 (C++ 제출)

### 전체 코드
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> nums(n);
    for (int i = 0; i < n; i++) cin >> nums[i];

    set<int> s(nums.begin(), nums.end());              // 중복 제거 + 정렬
    vector<int> uniq(s.begin(), s.end());               // 인덱싱을 위해 다시 벡터화

    unordered_map<int, int> rank;                       // 값 -> 압축 인덱스
    for (int i = 0; i < (int)uniq.size(); i++) rank[uniq[i]] = i;

    for (int x : nums) cout << rank[x] << ' ';
    return 0;
}
```

### 로직 설명 + 코드

* `set`으로 중복 제거 및 자동 정렬 후, 벡터에 담아 인덱스를 부여한다.  
```cpp
set<int> s(nums.begin(), nums.end());
vector<int> uniq(s.begin(), s.end());
```

* 해시 맵에 값→압축 인덱스를 저장하고 입력 순서대로 출력.  
```cpp
unordered_map<int, int> rank;
for (int i = 0; i < (int)uniq.size(); i++) rank[uniq[i]] = i;
for (int x : nums) cout << rank[x] << ' ';
```

### 장단점

* 장점: 파이썬 풀이와 동일한 로직을 C++ STL로 구현, `O(N log N)` 정렬 후 `O(1)` 평균 조회.
* 단점: `set`→`vector` 변환이 한 번 더 들어가며, `unordered_map`의 상수 시간이 해시 품질에 따라 달라질 수 있다.

---

## 풀이 3 — bisect 활용 조회 (AI 제안)

### 전체 코드
```python
import sys, bisect

input = sys.stdin.readline

N = int(input())
nums = list(map(int, input().split()))

uniq = sorted(set(nums))

out = (str(bisect.bisect_left(uniq, x)) for x in nums)
sys.stdout.write(" ".join(out))
```

### 로직 설명 + 코드

* 매핑 딕셔너리 대신 `bisect_left`로 인덱스를 구한다.
```python
out = (str(bisect.bisect_left(uniq, x)) for x in nums)
sys.stdout.write(" ".join(out))
```
* 유니크 리스트가 이미 정렬되어 있으므로 이진 탐색으로 압축값을 찾는다.

### 장단점

* 장점: 매핑 딕셔너리 생성 없이 바로 조회 가능.
* 단점: 각 조회가 `O(log N)`이라 `O(N log N)` 유지, 딕셔너리보다 느릴 수 있다.

---

## 비슷한 문제에서의 사고과정

* **좌표 압축 패턴**: 중복 제거 → 정렬 → 값→순위 매핑 → 원본 순서 출력.
* **범위가 작을 때**: 카운팅/버킷으로 `O(N)`도 가능하지만, 범위가 클 때는 정렬 기반이 안전.
* **실수 포인트**: `list.index`로 순위 찾기처럼 선형 검색을 하면 `O(N^2)`가 되어 시간 초과, 반드시 정렬 후 해시/이진탐색으로 조회해야 한다.

---

## 정리 요약

* 유니크 값만 정렬하고 인덱스를 압축 좌표로 매핑해 출력한다.
* 해시를 쓰면 조회가 O(1)이라 전체 `O(N log N)`(정렬)로 해결.
* 좌표 압축은 값의 순서 정보만 필요할 때 쓰는 전형적 전처리 패턴이다.
