# BOJ 19942 — 다이어트 (w/ gpt-5.1-codex)  
(G4) - <https://www.acmicpc.net/problem/19942>

## 문제 정보
N(≤15)개의 재료가 주어지고, 네 영양소 최소치 `(mp, mf, ms, mv)`를 만족하도록 재료를 고른다. 총 비용이 최소인 조합을 찾고, 비용이 같으면 **사전순(인덱스 오름차순)**으로 가장 이른 조합을 출력한다. 불가능하면 -1.

---

## 사고흐름

1. N이 15라 모든 부분집합이 `2^15`로 충분히 탐색 가능 → DFS/백트래킹 채택.
2. 상태: 인덱스 `L`, 누적 영양 `(cp, cf, cs, cv)`, 비용 `cost`, 선택한 재료 목록.
3. 리프에서 영양 조건을 모두 충족하면 최소 비용을 갱신하고, 비용이 같으면 사전순 비교로 더 이른 조합을 선택.
4. 시간복잡도 `O(2^N * N)`(리스트 복사 포함), 메모리 `O(N)`.

---

## 핵심아이디어

- **부분집합 완탐**으로 비용 최소/사전순 tie-break를 모두 처리.
- 영양 소계와 비용을 누적하며, 리프에서만 조건을 검사해 분기 비용을 줄인다.
- 사전순은 DFS가 작은 인덱스부터 탐색하므로, **동일 비용 시 기존보다 더 짧거나 동일 리스트를 우선**한다.

---

## 풀이 1 — DFS로 부분집합 탐색 (내 제출)

### 전체 코드
```python
import sys

read = sys.stdin.readline

n = int(read())
mp, mf, ms, mv = map(int, read().split())
items = [list(map(int, read().split())) for _ in range(n)]  # p, f, s, v, cost

best_cost = float("inf")
best_pick = []


def dfs(idx, p, f, s, v, cost, pick):
    global best_cost, best_pick
    if idx == n:
        if p >= mp and f >= mf and s >= ms and v >= mv:
            if cost < best_cost or (cost == best_cost and pick < best_pick):
                best_cost = cost
                best_pick = pick[:]
        return

    dfs(idx + 1,
        p + items[idx][0],
        f + items[idx][1],
        s + items[idx][2],
        v + items[idx][3],
        cost + items[idx][4],
        pick + [idx + 1])  # 1-index 저장

    dfs(idx + 1, p, f, s, v, cost, pick)


dfs(0, 0, 0, 0, 0, 0, [])

if best_pick:
    print(best_cost)
    print(*best_pick)
else:
    print(-1)
```

### 로직 설명 + 코드

1) DFS 분기  
```python
def dfs(idx, p, f, s, v, cost, pick):
    global best_cost, best_pick
    if idx == n:
        if p >= mp and f >= mf and s >= ms and v >= mv:
            if cost < best_cost or (cost == best_cost and pick < best_pick):
                best_cost = cost
                best_pick = pick[:]
        return

    # 선택
    dfs(idx + 1,
        p + items[idx][0],
        f + items[idx][1],
        s + items[idx][2],
        v + items[idx][3],
        cost + items[idx][4],
        pick + [idx + 1])  # 1-index 저장

    # 비선택
    dfs(idx + 1, p, f, s, v, cost, pick)
```
* 리프에서만 조건을 검사해 불필요한 비교를 줄인다.
* 비용이 같을 때는 선택 리스트 사전순(`pick < best_pick`)으로 tie-break.

2) 실행 및 출력  
```python
dfs(0, 0, 0, 0, 0, 0, [])

if best_pick:
    print(best_cost)
    print(*best_pick)
else:
    print(-1)
```
* 유효 조합이 없으면 -1을 출력한다.

### 장단점

* 장점: N이 작아 완전 탐색이 단순하고 안전하다.
* 단점/개선 여지: 분기마다 리스트를 새로 만드는 비용이 있어, `pick.append/pop` 백트래킹으로 미세 최적화 가능.

---

## 풀이 2 — 백트래킹 최적화 (AI 제안)

### 전체 코드
```python
import sys

read = sys.stdin.readline

n = int(read())
mp, mf, ms, mv = map(int, read().split())
items = [list(map(int, read().split())) for _ in range(n)]

best_cost = float("inf")
best_pick = []
pick = []


def dfs(idx, p, f, s, v, cost):
    global best_cost, best_pick
    if idx == n:
        if p >= mp and f >= mf and s >= ms and v >= mv:
            if cost < best_cost or (cost == best_cost and pick < best_pick):
                best_cost = cost
                best_pick = pick[:]
        return

    pick.append(idx + 1)
    dfs(idx + 1,
        p + items[idx][0],
        f + items[idx][1],
        s + items[idx][2],
        v + items[idx][3],
        cost + items[idx][4])
    pick.pop()

    dfs(idx + 1, p, f, s, v, cost)


dfs(0, 0, 0, 0, 0, 0)

if best_pick:
    print(best_cost)
    print(*best_pick)
else:
    print(-1)
```

### 로직 설명 + 코드

* 선택 리스트를 재사용하며 push/pop으로 관리해 리스트 복사 비용을 줄인다.
```python
def dfs(idx, p, f, s, v, cost):
    global best_cost, best_pick
    if idx == n:
        if p >= mp and f >= mf and s >= ms and v >= mv:
            if cost < best_cost or (cost == best_cost and pick < best_pick):
                best_cost = cost
                best_pick = pick[:]
        return

    # 선택
    pick.append(idx + 1)
    dfs(idx + 1,
        p + items[idx][0],
        f + items[idx][1],
        s + items[idx][2],
        v + items[idx][3],
        cost + items[idx][4])
    pick.pop()

    # 비선택
    dfs(idx + 1, p, f, s, v, cost)

dfs(0, 0, 0, 0, 0, 0)
```
* 상태 변수는 스칼라이므로 재귀 인자로 전달, 선택 리스트만 백트래킹으로 재사용.

### 장단점

* 장점: 리스트 복사 감소로 상수 시간 향상.
* 단점: 근본 복잡도는 동일하며, 여전히 최악 `2^N` 분기.

---

## 비슷한 문제에서의 사고과정

* **작은 N의 조합 최적화**: 부분집합 완탐 + 조건/비용 체크, tie-break는 DFS 순서 + 사전순 비교로 해결.
* **출력 사전순 요구**: 비용이 같을 때 선택 리스트를 직접 비교해 결정.
* **백트래킹 성능**: 리스트 복사 대신 push/pop을 활용해 상수 시간 최적화.
* **실수 포인트**: 비용이 같은 경우 사전순 tie-break를 빼먹으면 채점 틀림; 리스트 비교 시 1-index/0-index 혼동에 주의.

---

## 정리 요약

* N=15라 부분집합 DFS로 모든 조합을 탐색하고, 최소 비용과 사전순 tie-break를 함께 관리한다.
* 선택 리스트를 사본 없이 백트래킹하면 상수 시간 손해를 줄일 수 있다.
* 작은 조합 최적화 문제는 완탐 + 명시적 tie-break 패턴을 재사용하면 안정적이다.
