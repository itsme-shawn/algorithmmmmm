# BOJ 11723 — 집합 (w/ gpt-5.1-codex)  
<https://www.acmicpc.net/problem/11723>

## 문제 정보
1~20 정수 집합에 대해 `add/remove/check/toggle/all/empty` 명령을 처리한다. 명령 수 `M ≤ 1,000,000`으로 빠른 입출력이 필요하다.

---

## 사고흐름

1. 원소 범위가 20개뿐이라 비트마스크도 가능하지만, 실수 위험을 줄이기 위해 **set**을 우선 선택.
2. 여섯 명령을 함수/분기별로 직접 매핑하고, `all/empty`는 집합 **참조를 유지한 채 내용만 변경**해야 함.
3. `check` 결과를 리스트에 모아 한 번에 출력해 I/O 병목을 줄인다.
4. 시간복잡도: 각 연산 평균 `O(1)` → 전체 `O(M)`.

---

## 핵심아이디어

- **집합 연산 그대로 매핑**해 모든 명령을 평균 `O(1)`에 처리.
- **`clear`+`update`로 참조 유지**: `all/empty`에서 새 집합을 만들지 않고 기존 집합을 비워 채운다.
- 출력은 리스트에 모아 `'\n'.join`으로 한 번에 처리해 입출력을 최소화한다.

---

## 풀이 1 — set 기반 명령 매핑 (내 제출)

### 전체 코드
```python
import sys

read = sys.stdin.readline


def add(s: set, x: int) -> None:
    s.add(x)


def remove(s: set, x: int) -> None:
    s.discard(x)  # 존재 여부 확인 없이 안전 제거


def check(s: set, x: int) -> int:
    return 1 if x in s else 0


def toggle(s: set, x: int) -> None:
    if x in s:
        s.remove(x)
    else:
        s.add(x)


s = set()
out = []

for _ in range(int(read())):
    parts = read().split()
    cmd = parts[0]

    if cmd == "add":
        add(s, int(parts[1]))
    elif cmd == "remove":
        remove(s, int(parts[1]))
    elif cmd == "check":
        out.append(check(s, int(parts[1])))
    elif cmd == "toggle":
        toggle(s, int(parts[1]))
    elif cmd == "all":
        s.clear()
        s.update(range(1, 21))  # 참조 유지
    else:  # empty
        s.clear()

sys.stdout.write("\n".join(map(str, out)))
```

### 로직 설명 + 코드

1) 명령 처리 루프  
```python
s = set()
out = []

for _ in range(int(read())):
    parts = read().split()
    cmd = parts[0]

    if cmd == "add":
        add(s, int(parts[1]))
    elif cmd == "remove":
        remove(s, int(parts[1]))
    elif cmd == "check":
        out.append(check(s, int(parts[1])))
    elif cmd == "toggle":
        toggle(s, int(parts[1]))
    elif cmd == "all":
        s.clear()
        s.update(range(1, 21))  # 참조 유지
    else:  # empty
        s.clear()
```
* 여섯 명령을 그대로 set 연산에 매핑한다. `discard`/`clear`로 예외 없이 처리.

2) 결과 출력  
```python
sys.stdout.write("\n".join(map(str, out)))
```
* `check` 결과만 모아 한 번에 출력해 I/O 부하를 줄인다.

### 장단점

* 장점: 구현이 직관적이며 평균 `O(1)` 연산으로 M이 커도 안전.
* 단점/개선 여지: 범위가 작으므로 비트마스크로 더 빠른 구현 가능.

---

## 풀이 2 — 비트마스크 최적화 (AI 제안)

```python
import sys

read = sys.stdin.readline

mask = 0
FULL = (1 << 20) - 1
out = []

for _ in range(int(read())):
    parts = read().split()
    cmd = parts[0]

    if cmd == "add":
        mask |= 1 << (int(parts[1]) - 1)
    elif cmd == "remove":
        mask &= ~(1 << (int(parts[1]) - 1))
    elif cmd == "check":
        out.append(1 if mask & (1 << (int(parts[1]) - 1)) else 0)
    elif cmd == "toggle":
        mask ^= 1 << (int(parts[1]) - 1)
    elif cmd == "all":
        mask = FULL
    else:  # empty
        mask = 0

sys.stdout.write("\n".join(map(str, out)))
```

### 로직 설명 + 코드

* 집합을 20비트 정수 하나로 표현한다. `all/empty`는 한 번의 대입으로 끝나고, 나머지는 비트 OR/AND/XOR로 처리.
* `check`는 해당 비트가 켜져 있는지로 1/0을 바로 얻는다.

### 장단점

* 장점: 상수 메모리, 최소 오버헤드로 가장 빠른 구현.
* 단점: 비트 인덱스(`-1`) 실수 가능성이 있어 가독성이 `set`보다 떨어진다.

---

## 비슷한 문제에서의 사고과정

* **원소 수가 작을 때**: 비트마스크가 성능/메모리 최적. 범위가 크면 `set`이나 `dict`로 전환.
* **명령형 입출력**: 결과는 모아서 출력해 I/O 병목을 피하고, 상태 객체 참조를 유지해야 하는 명령은 재할당 대신 내용만 수정.
* **실수 포인트**: `all/empty`에서 집합을 새로 할당하면 참조가 끊어져 오답 가능; 출력 시마다 `print`를 바로 호출하면 I/O 병목으로 시간 초과가 날 수 있다.

---

## 정리 요약

* 여섯 명령을 set 또는 비트 연산에 직접 매핑해 평균 `O(1)`에 처리한다.
* `all/empty`는 참조 유지가 핵심이며, 출력은 모아 한 번에 처리해 속도를 확보한다.
* 범위가 작으면 비트마스크, 가독성이 필요하면 set이 안전한 선택이다.
