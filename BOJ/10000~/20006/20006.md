# BOJ 20006 — 랭킹전 대기열 (w/ gpt-5.1-codex)  
<https://www.acmicpc.net/problem/20006>

## 문제 정보
플레이어 `P`명(레벨, 닉네임)이 주어진다. 방장은 첫 입장 플레이어, 이후 레벨이 **방장 레벨 ±10**이고 정원 `m`이 남은 방에 배치한다. 조건을 만족하는 방이 없으면 새 방을 만든다. 각 방의 닉네임을 사전순으로 출력하고, 정원이 꽉 차면 `Started!`, 아니면 `Waiting!`을 출력한다. `P ≤ 300`.

---

## 사고흐름

1. 입력 순서대로 방을 순회하며 조건을 만족하는 첫 방에 입장시킨다.
2. 방마다 방장 레벨을 저장해 비교, 정원이 꽉 찼으면 건너뛰기.
3. 조건을 만족하는 방이 없으면 새 방을 생성하고 현재 플레이어를 방장으로 둔다.
4. 출력 시 닉네임만 사전순 정렬, 나머지 순서는 입력 유지.

---

## 핵심아이디어

- 방을 **리스트로 유지**하며 `(레벨, 닉네임)` 저장, 방장 레벨은 방 첫 요소의 레벨.
- **입력 순회 + 최초 적합 방에 입장**하면 문제 규칙과 일치.
- 출력은 **방 내부만 닉네임 사전순**으로 정렬.

---

## 풀이 1 — 순차 방 탐색 (내 제출)

### 전체 코드
```python
import sys

read = sys.stdin.readline

p, m = map(int, read().split())
rooms = []

for _ in range(p):
    level, name = read().split()
    level = int(level)

    for room in rooms:
        master_level = room[0][0]
        if len(room) < m and master_level - 10 <= level <= master_level + 10:
            room.append((level, name))
            break
    else:
        rooms.append([(level, name)])

for room in rooms:
    print("Started!" if len(room) == m else "Waiting!")
    for lv, nm in sorted(room, key=lambda x: x[1]):
        print(lv, nm)
```

### 로직 설명 + 코드

1) 플레이어 배치  
```python
for room in rooms:
    master_level = room[0][0]
    if len(room) < m and master_level - 10 <= level <= master_level + 10:
        room.append((level, name))
        break
else:
    rooms.append([(level, name)])
```
* 기존 방을 순회하며 조건을 만족하면 입장, 없으면 새 방을 만든다.

2) 결과 출력  
```python
print("Started!" if len(room) == m else "Waiting!")
for lv, nm in sorted(room, key=lambda x: x[1]):
    print(lv, nm)
```
* 정원 여부로 문구를 결정하고, 닉네임 사전순으로 정렬해 출력한다.

### 장단점

* 장점: 구현이 간단하고 입력 크기(P ≤ 300)에서 충분히 빠르다.
* 단점/개선 여지: 방 수가 많을 때도 매번 선형 탐색; 조건을 나누면 상수 개선 가능.

---

## 풀이 2 — 레벨 범위별 버킷 탐색 (AI 제안)

### 전체 코드
```python
import sys

read = sys.stdin.readline

p, m = map(int, read().split())
rooms = []  # (lo, hi, players)

for _ in range(p):
    level, name = read().split()
    level = int(level)

    placed = False
    for room in rooms:
        lo, hi, players = room
        if len(players) < m and lo <= level <= hi:
            players.append((level, name))
            placed = True
            break
    if not placed:
        rooms.append((level - 10, level + 10, [(level, name)]))

for _, _, players in rooms:
    print("Started!" if len(players) == m else "Waiting!")
    for lv, nm in sorted(players, key=lambda x: x[1]):
        print(lv, nm)
```

### 로직 설명 + 코드

* 방을 만들 때 **방장 레벨 범위(lo, hi)**를 저장해 조건 검사를 명확히 한다.
```python
if len(players) < m and lo <= level <= hi:
    players.append((level, name))
    placed = True
    break
```
* 적합한 방을 찾으면 추가, 없으면 `(level-10, level+10)` 범위의 새 방을 만든다.

### 장단점

* 장점: 방 정보가 명시적이라 가독성이 좋고 조건 검사를 단순화.
* 단점: 복잡도는 여전히 선형 탐색이지만, 규모가 작아 문제 없음.

---

## 비슷한 문제에서의 사고과정

* **조건에 맞는 첫 컨테이너 배치**: 입력 순서대로 적합한 컨테이너를 찾고, 없으면 새 컨테이너 생성.
* **정원/범위 체크**: 방장 기준 범위를 저장하면 조건 검사가 명확해진다.
* **출력 정렬 분리**: 배치 순서는 그대로 두고, 출력 시 필요한 기준(닉네임)만 정렬.
* **실수 포인트**: 방장 레벨 범위만 보면 되는데 이전 입장자의 레벨로 범위를 갱신하면 규칙을 어긴다; 닉네임 정렬은 출력에서만 적용해야 한다.

---

## 정리 요약

* 방장 레벨 ±10 범위, 정원 `m`을 만족하는 첫 방에 넣고, 없으면 새 방을 만든다.
* 출력은 방별 닉네임 사전순, 정원 여부로 `Started!/Waiting!` 결정.
* 조건부 배치 문제에서는 입력 순서 처리와 출력 정렬을 분리해 구현을 단순화한다.
