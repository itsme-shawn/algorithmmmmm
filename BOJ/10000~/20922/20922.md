# BOJ 20922 — 겹치는 건 싫어 (w/ gpt-5.1-codex)  
(S1) - <https://www.acmicpc.net/problem/20922>

## 문제 정보
수열 길이 `N ≤ 200,000`, 각 원소가 윈도우 내에서 **최대 K번** 이하로만 등장하도록 하는 가장 긴 연속 부분 수열의 길이를 구한다.

---

## 사고흐름

1. 구간 내 빈도 제약(`<= K`)을 만족하는 최대 길이 → **슬라이딩 윈도우**가 적합.
2. 오른쪽으로 한 칸씩 확장하며 빈도를 증가시키고, 제약을 넘으면 왼쪽을 줄여 복구.
3. 매 단계에서 윈도우 길이로 답을 갱신하면 된다. 시간복잡도 `O(N)`.

---

## 핵심아이디어

- **빈도 해시 + 덱/포인터**로 현재 구간을 관리.
- 새 원소 추가 후 `count[num] > K`이면 왼쪽을 빼며 제약을 회복.
- 윈도우 길이는 `right - left + 1` 혹은 덱 길이로 바로 구한다.

---

## 풀이 1 — 덱 기반 슬라이딩 윈도우 (내 제출 원본)

### 전체 코드
```python
import sys
from collections import deque

read = sys.stdin.readline

n, k = map(int, read().split())
nums = list(map(int, read().split()))
window = deque()
count = {}
best = 0

for num in nums:
    count[num] = count.get(num, 0) + 1
    window.append(num)

    if count[num] > k: # 새로운 숫자가 최대빈도수 초과했다면
        while count[num] > k: # 뺄 수 있을때까지 값 빼기
            left = window.popleft()
            count[left] -= 1

    best = max(best, len(window))

print(best)
```

### 로직 설명
- 덱 `window`로 현재 구간을 유지하며 오른쪽으로 확장한다.
- 새 원소로 빈도가 `K`를 넘으면 해당 값이 `K` 이하가 될 때까지 왼쪽을 `popleft`한다.
- 매 스텝 덱 길이로 최댓값을 갱신한다.

### 피드백
- 덱을 쓰면 직관적이지만, 실제로 필요한 것은 인덱스 범위뿐이라 포인터(`l`, `r`)로 대체하면 더 가볍다.
- `if` 뒤 `while`을 바로 쓰는 대신 조건 없이 `while count[num] > k:`로 바로 진입해도 된다(기능은 같음).

---

## 풀이 1.1 — 덱 기반 슬라이딩 윈도우 (AI 첨삭)
```python
import sys
from collections import deque

read = sys.stdin.readline

n, k = map(int, read().split())
nums = list(map(int, read().split()))

window = deque()
count = {}
best = 0

for num in nums:
    count[num] = count.get(num, 0) + 1
    window.append(num)

    while count[num] > k:
        left = window.popleft()
        count[left] -= 1

    if len(window) > best:
        best = len(window)

print(best)
```
- 원본 로직을 유지하면서 `while`만 단순화했고, 조건문을 줄여 읽기 흐름을 직선화했다.
- 덱을 유지했기 때문에 원본과 같은 자료구조/동작을 한다.

---

## 풀이 2 — 투 포인터 (AI 제안)

### 전체 코드
```python
import sys

read = sys.stdin.readline

n, k = map(int, read().split())
nums = list(map(int, read().split()))

count = {}
best = 0
l = 0

for r, num in enumerate(nums):
    count[num] = count.get(num, 0) + 1
    while count[num] > k:
        left_num = nums[l]
        count[left_num] -= 1
        l += 1
    best = max(best, r - l + 1)

print(best)
```

### 로직 설명 + 코드

* 오른쪽 포인터 `r`를 확장하며 빈도를 증가, 제약 위반 시 왼쪽 포인터를 이동.
```python
for r, num in enumerate(nums):
    count[num] = count.get(num, 0) + 1
    while count[num] > k:
        left_num = nums[l]
        count[left_num] -= 1
        l += 1
    best = max(best, r - l + 1)

print(best)
```
* 덱 없이 인덱스만으로 윈도우를 표현해 상수 비용을 줄인다.

### 장단점

* 장점: 메모리 사용이 덱보다 더 작고, 덱 연산 오버헤드가 없다.
* 단점: 로직은 동일하므로 가독성 취향 차이.

---

## 비슷한 문제에서의 사고과정

* **빈도 제한 구간 최적화**: 슬라이딩 윈도우/투 포인터로 빈도를 관리하며 제약을 유지.
* **제약을 깨면 왼쪽 축소**: 새 원소 때문에 제약이 깨지면 while로 복구 후 길이를 갱신.
* **실수 포인트**: 새 원소를 넣은 뒤 바로 길이를 갱신하면 빈도 초과 구간을 포함해버릴 수 있으니, 초과를 먼저 해소하고 나서 길이를 계산해야 한다.

---

## 정리 요약

* 빈도 제약 `<= K`를 유지하며 윈도우를 확장/축소해 최장 길이를 찾는다.
* 해시로 빈도를 관리하고, 제약 위반 시 왼쪽을 줄이는 패턴은 다른 빈도 제한 슬라이딩 문제에도 그대로 쓸 수 있다.

---

## 풀이 3 — Java 개선 (투 포인터)

### 전체 코드
```java
import java.io.*;
import java.util.*;

class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());

        int[] nums = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }

        int[] count = new int[200001];
        int best = 0;
        int left = 0;

        for (int right = 0; right < n; right++) {
            int v = nums[right];
            count[v]++;
            while (count[v] > k) {
                count[nums[left]]--;
                left++;
            }
            int len = right - left + 1;
            if (len > best) best = len;
        }

        System.out.println(best);
    }
}
```

### 로직 설명 + 코드
- 오른쪽 포인터를 확장하면서 빈도를 늘리고, 현재 값이 `K`를 넘으면 왼쪽을 줄여 복구한다.
```java
for (int right = 0; right < n; right++) {
    int v = nums[right];
    count[v]++;
    while (count[v] > k) {
        count[nums[left]]--;
        left++;
    }
    int len = right - left + 1;
    if (len > best) best = len;
}
```

### 핵심 포인트
- 덱 대신 **투 포인터 + 빈도 배열**만 사용해 로직을 단순화.
- `BufferedReader + StringTokenizer`로 입력을 처리해 `N=200,000`에서도 안정적으로 통과.
- `count` 배열 크기는 문제의 값 범위를 넉넉하게 잡아 상수 시간을 유지.

### 장단점
- 장점: 덱 제거로 상수 비용이 줄고, 메모리/속도 모두 단순함.
- 단점: 값 범위가 커질 때는 배열 대신 해시맵으로 바꿔야 한다.
