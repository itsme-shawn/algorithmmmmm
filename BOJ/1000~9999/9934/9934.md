# BOJ 9934 — 완전 이진 트리 복원 (w/ chatgpt)

## 문제 요약
깊이 `K`(1 ≤ K ≤ 10)인 **완전 이진 트리**가 있으며, 이 트리를 **중위 순회(Inorder)** 한 결과가 입력으로 주어진다.  
입력된 순서만으로 원래 트리의 구조를 복원한 뒤, **각 레벨의 노드들을 왼쪽→오른쪽 순서로 출력**하는 문제다.  
완전 이진 트리는 총 `2^K - 1`개의 노드를 갖는다.

---

## 사고 흐름

1. **주어진 방문 규칙이 무엇인지 판별**  
   조건을 읽어보면 “왼쪽 자식 → 현재 노드 → 오른쪽 자식” 규칙이므로 이는 전형적인 **중위 순회**이다.

2. **트리 구조 파악**  
   트리는 “깊이 K의 완전 이진 트리”이며, 이는 곧 **배열로 표현 가능한 포화 이진 트리**임을 의미한다.  
   - 노드 수: `N = 2^K - 1`
   - 인덱스 규칙:  
     - left: `2*n + 1`  
     - right: `2*n + 2`
   - 레벨 인덱스 범위:  
     - 레벨 `L` → `[2^L - 1, 2^(L+1) - 2]`

3. **해결 전략 결정**  
   트리를 복원하는 방식은 두 가지가 존재한다.
   - 방법 1: **트리를 직접 배열로 구성하고, 입력(inorder) 배열을 중위순회하며 주입**.
   - 방법 2: **inorder 배열을 절반씩 분할하여 레벨별 노드를 직접 구성**.

4. **시간복잡도 고려**  
   두 방식 모두 총 노드 수 `2^K - 1 (≤ 1023)`에 대해 한 번의 재귀 순회를 수행하므로  
   **시간복잡도 O(N)**, 메모리 사용량도 충분히 작아 무리 없음.

---

## 핵심 아이디어

- 입력은 완전 이진트리의 **중위순회 결과**이며,  
  완전 이진트리는 항상 **중앙값이 루트**라는 성질을 가진다.
- 이 성질을 이용해 트리를 실제 인덱스 구조로 복원할 수도 있고,  
  혹은 inorder 배열을 구간 단위로 분할하며 레벨 배열을 직접 구성할 수도 있다.

---

# 풀이 1 — 배열 기반 이진트리 구성 후 중위 순회로 값 주입

```python
# 직접 이진트리 순회하면서 값 저장하기

import sys
# sys.stdin = open("in.txt", "r")
read = sys.stdin.readline

k = int(read())
nodes = list(map(int, read().split()))

tree = [0] * (2**k-1)

# tree = list(range(1,2**k))

i = 0

def mid_order(n):
    global i
    if n < 2**k - 1:
        mid_order(n*2 + 1)
        # print(tree[n])
        tree[n] = nodes[i]
        i += 1
        mid_order(n*2 + 2)

mid_order(0)

for j in range(k):
    print(" ".join(map(str,tree[2**j-1:2**(j+1)-1])))
```

## 핵심 포인트
- 완전 이진 트리를 **배열 인덱스 기반**으로 구성하고  
  중위 순회 함수를 실행하면서 입력 값을 순서대로 tree 배열에 삽입한다.
- 순회가 끝난 후, 레벨별 인덱스 규칙에 따라 결과 출력.

## 로직 설명
1. 크기가 `2^K - 1`인 tree 배열을 생성한다.
2. 전역 인덱스 `i`를 유지하며 중위 순회를 수행한다.
3. 순회 과정에서 “왼쪽 → 현재 → 오른쪽” 순서로 tree 배열에 값을 채운다.
4. 레벨 `L`의 범위 `[2^L - 1 : 2^(L+1) - 1]`를 출력한다.

## 장단점
### 장점
- 트리 구조가 명시적으로 존재하므로 **직관적**이며 재사용성 높음.
- 배열 기반 완전 이진트리 구현을 확실히 익힐 수 있음.

### 단점
- 전역 인덱스(`i`) 의존.
- 트리 배열이 추가로 필요하므로 메모리 사용이 조금 더 많음(문제 규모에서는 문제 없음).

---

# 풀이 2 — inorder 배열을 절반씩 분할하며 레벨별 구성

```python
# 순회결과를 절반씩 쪼개가면 레벨별로 트리저장

import sys
# sys.stdin = open("in.txt", "r")
read = sys.stdin.readline

k = int(read())
inorders = list(map(int, read().split())) # 중위순회로 방문한 순서 (입력값)

levels = [[] for _ in range(k)] # 각 레벨 별 노드 저장할 정답 배열

i = 0

def build(L, start, end):
    if L == k:
        return
    mid = (start+end) // 2
    levels[L].append(inorders[mid])
    # print(f"{L=} {start=} {end=} {mid=} {inorders[mid]}")
    build(L+1, start, mid-1)
    build(L+1, mid+1, end)

build(0,0,2**k-2)

for level in levels:
    print(*level)
```

## 핵심 포인트
- 완전 이진트리에서 중위 순회 결과의 **중앙값이 루트**임을 이용한 분할정복 방식.
- 트리를 따로 구성하지 않고 **레벨 배열(levels)** 을 직접 생성한다.

## 로직 설명
1. 함수 `build(level, start, end)`를 정의한다.
2. 현재 구간의 중앙 인덱스 `mid = (start + end) // 2`를 선택하여  
   `levels[level]`에 추가한다.
3. 왼쪽 구간 → 왼쪽 서브트리, 오른쪽 구간 → 오른쪽 서브트리로 재귀 호출한다.
4. 모든 레벨이 채워지면 levels 배열을 그대로 출력한다.

## 장단점
### 장점
- 별도의 트리 배열이 필요 없어 **메모리 효율적**이며 깔끔한 구성.
- 분할정복 패턴이라 논리 구조가 명확함.

### 단점
- “왜 중앙이 루트인가?” 감이 없으면 처음 채택하기 어렵다.
- `start`, `end` 범위 관리에서 off-by-one 실수가 발생할 수 있음.

---

## 비슷한 문제에서의 사고 과정

1. **방문 규칙이 어떤 순회인지 즉시 판별**  
   - 전위(루트→L→R), 중위(L→루트→R), 후위(L→R→루트), 레벨순 등.

2. **트리 구조가 완전/포화인지 확인**  
   - 완전 이진 트리라면 배열 인덱스 기반 처리 가능.
   - 이때 레벨 범위와 자식 인덱스 규칙을 적극 활용.

3. **입력이 특정 순회 결과라면 구조 복원 방향 판단**
   - preorder + inorder → 트리 복원 가능  
   - inorder만으로는 구조 복원이 불가능하지만,  
     “완전 이진 트리”라는 조건이 있으므로 중앙값 원리 적용 가능

4. **구간 분할(recursion) 문제인지, 인덱스 트리 문제인지 구분**
   - 완전 이진트리 + 순회 결과 → 두 방식 모두 가능  
   - 문제 요구사항에 따라 더 단순한 쪽 채택

---

## 정리 요약

- 이 문제는 **완전 이진트리 + 중위순회** 조합을 이용해 구조를 복원하는 전형적인 문제이며,  
  배열 기반 트리 구성 방식과 구간 분할 방식을 모두 연습할 수 있다.
- 풀이 1은 **트리를 직접 구성**하는 방식,  
  풀이 2는 **중위 순회 배열을 분할정복으로 처리**하는 방식이다.
- 두 방법 모두 시간복잡도 O(2^K), K ≤ 10이므로 충분히 효율적이며  
  상황에 따라 편한 방식을 선택하면 됨.
