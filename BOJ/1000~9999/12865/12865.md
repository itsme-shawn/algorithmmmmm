````markdown
# BOJ 12865 — 평범한 배낭 (w/ chatgpt)

## 문제 요약
무게 제한 `K`가 있는 배낭에, `N`개의 물건(각각 무게 `W`, 가치 `V`) 중 일부를 골라 넣을 때  
넣을 수 있는 물건들의 **가치합의 최댓값**을 구하는 0/1 배낭 문제.  
각 물건은 **넣거나(1), 안 넣거나(0)** 둘 중 하나만 선택 가능함. (쪼개기 불가)

---

## 사고흐름

1. 완전탐색 시도  
   - 각 물건마다 넣을지 말지 선택 → 경우의 수 `2^N` → `N ≤ 100`이므로 불가능함.
   - 더 효율적인 탐색 필요.

2. 상태 정의 고민  
   - “어디까지 봤는지 + 현재까지 배낭 무게”를 상태로 잡으면 됨.  
   - 전형적인 DP 상태:
     - 2차원: `dp[i][w]` = `i`번째 물건까지 고려했을 때, 무게 `w`로 만들 수 있는 최대 가치.
     - 1차원 최적화: `dp[w]` = “현재까지 고려한 물건들로, 무게 `w`에서의 최대 가치”.

3. 전이 규칙  
   - `i`번째 물건의 (무게, 가치)를 `(W_i, V_i)`라 할 때:
     - 안 넣는 경우: `dp[i][w] = dp[i-1][w]`
     - 넣는 경우(무게 허용 시): `dp[i][w] = dp[i-1][w - W_i] + V_i`
   - 둘 중 최대값 선택.

4. 시간·공간 복잡도  
   - `N ≤ 100`, `K ≤ 100000`
   - DP 점화식 한 번 계산할 때 O(1)
   - 전체 상태 수: `N * K` → 시간복잡도 `O(NK)` (최대 10^7 연산 정도 → 충분히 가능)
   - 2차원 DP: 메모리 `O(NK)`  
   - 1차원 DP: 메모리 `O(K)`로 줄일 수 있음.

---

## 핵심아이디어

- “**무게 제한을 넘지 않는 선에서 가치의 합을 최대화**” → 전형적인 **0/1 냅색(Knapsack)** DP.
- 각 물건을 **한 번만** 사용할 수 있으므로
  - 2차원 DP에서는 `i-1` 행만 참조
  - 1차원 DP에서는 **역방향(무게 `K → W_i`)으로 순회**해야 함.
    - 정방향으로 돌리면 같은 물건을 여러 번 사용하는 **무한(완전) 배낭**이 되어버림.
- 최종 정답은
  - 2차원: `dp[N][K]`
  - 1차원: `max(dp[0..K])` (이 문제에선 `dp[K]`를 바로 써도 됨)

---

## 풀이 1 — 1차원 DP, 역방향 순회 (공간 최적화)

```python
# 냅색 알고리즘
# 일차원 dp 배열 (역방향 순회)

import sys
# sys.stdin = open("in.txt", "r")
read = sys.stdin.readline

n, k = map(int, read().split())  # 물품 수, 가방의 한계 무게
items = [list(map(int, read().split())) for _ in range(n)]  # [무게, 가치]

dp = [0] * (k + 1)  # dp[w] = 무게 w로 얻을 수 있는 최대 가치

for w, v in items:
    if w > k:
        continue  # 애초에 배낭에 들어갈 수 없는 물건은 스킵
    # 역방향 순회: 같은 물건을 여러 번 쓰지 않기 위해 뒤에서부터 업데이트
    for i in range(k, w - 1, -1):  # i: 현재 고려하는 무게
        dp[i] = max(dp[i], dp[i - w] + v)

print(dp[k])
````

### 핵심 포인트

* 상태: `dp[w]` = “배낭 허용 무게가 `w`일 때 가능한 최대 가치”.
* 진행: 각 물건에 대해, 무게 `k`부터 `w`까지 **역순**으로 돌며 갱신.

  * `dp[i] = max(현재 값, 이 물건을 넣었을 때의 값)`
* 역방향 순회 덕분에

  * 아직 처리하지 않은 “이전 물건들 기준 dp”를 기준으로만 전이됨.
  * 같은 물건을 중복해서 사용하는 일이 없음 → 0/1 배낭 성질 유지.
* 공간복잡도 `O(K)`로 최적화됨.

### 로직 설명 (중요부분만)

예제 입력 기준:

```text
N = 4, K = 7
(6, 13), (4, 8), (3, 6), (5, 12)
```

1. 초기 상태

   * `dp = [0, 0, 0, 0, 0, 0, 0, 0]`  (인덱스: 0~7)

2. 첫 번째 물건 (6, 13)

   * `i`를 7 → 6까지 역방향 순회
   * `i = 7`: `dp[7] = max(dp[7], dp[1] + 13) = max(0, 0 + 13) = 13`
   * `i = 6`: `dp[6] = max(dp[6], dp[0] + 13) = 13`
   * 결과: `dp = [0,0,0,0,0,0,13,13]`

3. 두 번째 물건 (4, 8)

   * `i`를 7 → 4까지 역방향 순회
   * `i = 7`: `dp[7] = max(13, dp[3] + 8 = 0+8) = 13` (변화 없음)
   * `i = 6`: `dp[6] = max(13, dp[2] + 8 = 0+8) = 13` (변화 없음)
   * `i = 5`: `dp[5] = max(0, dp[1] + 8 = 0+8) = 8`
   * `i = 4`: `dp[4] = max(0, dp[0] + 8 = 8) = 8`
   * 결과: `dp = [0,0,0,0,8,8,13,13]`

4. 세 번째 물건 (3, 6)

   * `i`를 7 → 3까지 역방향 순회
   * `i = 7`: `dp[7] = max(13, dp[4] + 6 = 8+6=14) = 14`

     * 의미: (4,8) + (3,6) 조합으로 무게7, 가치14 달성
   * 나머지들도 비슷하게 갱신되지만, 핵심은 `dp[7]`가 14가 됨.
   * 이 시점에 이미 **정답 후보 14** 도출.

5. 네 번째 물건 (5, 12)

   * `i`를 7 → 5까지 역방향 순회
   * `i = 7`: `dp[7] = max(14, dp[2] + 12 = 12) = 14`
   * `i = 6`: `dp[6] = max(13, dp[1] + 12 = 12) = 13`
   * `i = 5`: `dp[5] = max(8, dp[0] + 12 = 12) = 12`
   * 최종: `dp[7] = 14` 유지

최종 출력: `dp[7] = 14` → 예제 출력과 일치.

### 장단점

* 장점

  * 메모리 사용량 `O(K)` → 매우 효율적.
  * 구현이 간결함.
  * 0/1 배낭의 전형적인 최적 풀이 패턴을 익히기 좋음.
* 단점

  * 2차원 DP에 비해 “어떤 선택을 했는지”를 복원하기는 더 불편함.
  * 역방향 순회 조건을 까먹으면 틀리기 쉬움. (정방향으로 돌리면 다른 문제가 됨)

---

## 풀이 2 — 2차원 DP, 정방향 순회 (직관적인 형태)

```python
# 냅색 알고리즘
# 이차원 dp 배열 (정방향 순회)

import sys
# sys.stdin = open("in.txt", "r")
read = sys.stdin.readline

n, k = map(int, read().split())  # 물품 수, 가방의 한계 무게
items = [list(map(int, read().split())) for _ in range(n)]  # [무게, 가치]
items.insert(0, [0])  # 1-index용 더미

dp = [[0] * (k + 1) for _ in range(n + 1)]
# dp[i][j] = i번째 물건까지 고려했을 때, 배낭 허용 무게 j에서의 최대 가치

for i in range(1, n + 1):
    weight = items[i][0]
    value = items[i][1]
    for j in range(1, k + 1):
        if j - weight >= 0:
            # i번째 물건을 안 넣는 경우 vs 넣는 경우
            dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight] + value)
        else:
            # 아예 못 넣는 경우 → 이전 상태 유지
            dp[i][j] = dp[i-1][j]

print(dp[n][k])
```

### 핵심 포인트

* 상태: `dp[i][j]`

  * `i`: 앞에서부터 `i`번째 물건까지 고려
  * `j`: 현재 배낭 허용 무게
  * 값: 최대 가치
* 점화식:

  * `j < weight` → 넣을 수 없음 → `dp[i][j] = dp[i-1][j]`
  * `j ≥ weight` → 둘 중 큰 값 선택

    * 안 넣기: `dp[i-1][j]`
    * 넣기: `dp[i-1][j - weight] + value`
* 항상 **윗행(i-1)** 만 참조하므로 0/1 배낭 조건이 자연스럽게 유지됨.

### 로직 설명 (중요부분만)

예제 입력 기준 상태 일부만 간단히 보면:

* `i = 1` (물건 (6,13))

  * `j < 6` → 모두 0
  * `j ≥ 6` → `dp[1][6] = dp[0][0] + 13 = 13`, `dp[1][7] = dp[0][1] + 13 = 13`
* `i = 2` (물건 (4,8))

  * `j = 4` → `max(dp[1][4], dp[1][0] + 8) = max(0, 8) = 8`
  * `j = 7` → `max(dp[1][7]=13, dp[1][3]+8=8) = 13`
* `i = 3` (물건 (3,6))

  * `j = 7` → `max(dp[2][7]=13, dp[2][4]+6=8+6=14) = 14`

    * 여기서 처음으로 14가 나옴.
* `i = 4`까지 진행해도 `dp[4][7] = 14` 유지.

최종 `dp[4][7] = 14` → 정답.

### 장단점

* 장점

  * 상태가 명확해서 **직관적**임.
  * 나중에 선택한 물건을 역추적하고 싶을 때 유리함.
  * 0/1 배낭 점화식을 익히기 좋은 기본 형태.
* 단점

  * 메모리 사용량이 `O(NK)`라서 1차원보다 큼.
  * 이 문제에서는 `100 * 100000 = 10^7` 정도라 버틸 수 있으나, 상한이 더 크면 부담될 수 있음.

---

## 비슷한 문제에서의 사고과정

유사 유형(0/1 배낭, 부분합 최적화 등)에서의 공통 패턴:

1. “선택/비선택” 구조 파악

   * 각 원소에 대해 “고를지/말지”가 분명하면 0/1 배낭, 부분합 DP일 가능성이 큼.

2. 상태 정의

   * 보통:

     * 인덱스(어디까지 봤는지)
     * 용량/제약(무게, 비용, 시간 등)
   * → `dp[i][c]` 또는 최적화해 `dp[c]` 형태로 정의.

3. 전이 규칙 세우기

   * 안 쓰는 경우 vs 쓰는 경우 둘 중 최대/최소를 선택.
   * “한 번만”인지 “여러 번”인지에 따라

     * 0/1 배낭: 2차원 또는 1차원 역방향 순회
     * 무한 배낭: 1차원 정방향 순회

4. 제한 크기 보고 DP 가능 여부 판단

   * `N * K`가 대략 10^7 이하면 대부분 시간 내 해결 가능.
   * 이보다 크면 다른 아이디어(그리디, 다른 DP 설계 등)를 고민해야 함.

---

## 정리 요약

* BOJ 12865는 전형적인 **0/1 배낭(DP) 기본 문제**임.
* 핵심 상태:

  * 2차원: `dp[i][w]` = `i`번째 물건까지 봤을 때, 무게 `w`에서의 최대 가치
  * 1차원: `dp[w]` = 지금까지 고려한 물건들로 무게 `w`에서의 최대 가치
* 1차원 DP는 **역방향 순회**로 같은 물건의 중복 사용을 방지하는 것이 핵심 포인트.
* 예제 `(4,7)` 기준으로도, `(4,8) + (3,6)` 조합을 통해 최대 가치 14를 자연스럽게 도출할 수 있음.
* 실전에서 이 문제는

  * “0/1 배낭 기본 템플릿”을 익히고,
  * 2차원 → 1차원으로 최적화하는 패턴을 연습하기에 좋음.