# BOJ 1316 — 그룹 단어 체커 (w/ chatgpt)

## 문제 요약

* 그룹 단어: 어떤 문자든지 “한 번 등장하기 시작하면, 그 이후에는 끊기지 않고 연속으로만 등장하는” 단어
* 예시

  * `ccazzzzbb` → c, a, z, b 모두 연속 → 그룹 단어
  * `aabbbccb` → b가 `bbb` 이후 다시 `b`로 등장 → 그룹 단어 아님
* 단어 N개가 주어질 때, 그룹 단어의 개수를 세는 문제

제한

* 1 ≤ N ≤ 100
* 각 단어 길이 ≤ 100, 모두 소문자 알파벳

---

## 사고 흐름

1. **핵심 판별 기준 정리**

   * 문자열을 왼쪽→오른쪽으로 보면서,

     * 어떤 문자 `c`가 나왔다가
     * 다른 문자로 바뀐 뒤
     * 다시 `c`가 나오면 → 그룹 단어 아님

2. **필요한 정보**

   * “현재 연속 구간의 문자”
   * “지금까지 등장했던 문자 집합”
   * 매 글자를 순회하면서 위 두 정보를 갱신하면 됨

3. **자료구조 선택**

   * 현재 문자: 그냥 변수 하나 `cur` 또는 스택의 top
   * 과거에 등장한 문자:

     * `set` → 포함 여부 O(1)
     * 또는 리스트/스택 → 포함 여부 O(L), 하지만 L ≤ 100이라도 크게 문제는 없음

4. **시간복잡도**

   * 문자열 길이를 L, 단어 개수를 N이라고 할 때
   * 각 단어를 한 번 쭉 훑으므로 기본적으로 O(L)
   * set 사용 시: 전체 O(N * L)
   * 리스트 사용 시: 최악 O(N * L^2)이지만 L ≤ 100이라 충분히 통과 가능함

---

## 핵심 아이디어

* 문자열을 왼쪽부터 순회하면서

  * **이전 문자와 다르게 바뀌는 순간에만** “이 문자가 예전에 나온 적 있는지” 확인하면 됨
* “이전에 나온 적 있다” = “이미 다른 구간에서 쓴 적 있다”이므로
  → 그룹 단어가 아님
* 이 규칙만 지키면, 별도의 복잡한 알고리즘 없이 구현 가능

---

## 풀이 1 — set으로 등장 여부 체크 (사용자 풀이)

```python
import sys
read = sys.stdin.readline

n = int(read())
cnt = 0
for _ in range(n):
    s = read().rstrip()
    cur = s[0]
    sett = set()
    sett.add(cur)
    for i in range(1,len(s)):
        if s[i] != cur:
            cur = s[i]
            if cur in sett:
                break
            else:
                sett.add(cur)
    else:
        cnt += 1            

print(cnt)
```

### 핵심 포인트

* `cur`로 현재 연속 구간의 문자를 추적
* `sett`에 지금까지 등장한 문자들을 저장
* 문자가 바뀌는 순간(`s[i] != cur`)에만

  * 이미 `sett` 안에 있으면 → 그룹 단어 아님 → `break`
  * 없으면 → 새로 등장한 문자로 `sett`에 추가
* `for` 루프가 `break` 없이 끝나면 `else`가 실행되어 그룹 단어 카운트 증가

### 로직 설명 (중요부분만)

1. 단어 하나 읽기

   * `cur = s[0]` 으로 첫 글자를 현재 문자로 설정
   * `sett = {cur}` 으로 첫 문자를 등장 집합에 추가

2. 인덱스 1부터 끝까지 순회

   * `s[i] == cur` → 같은 문자 연속 구간이므로 그냥 통과
   * `s[i] != cur` → 새 문자가 시작되는 지점

     * `cur = s[i]` 로 현재 문자 갱신
     * 만약 `cur in sett` → 예전에 다른 구간에서 등장한 적 있는 문자 → 그룹 단어 아님 → `break`
     * 아니면 `sett.add(cur)` 로 새로 등장한 문자로 기록

3. `for` 루프가 끝까지 돌았을 때(`break` 없이 종료)

   * `for ... else` 구문에서 `else:` 블록 실행
     → 그룹 단어로 인정, `cnt += 1`

4. 모든 단어에 대해 위 과정을 반복하고, 마지막에 `cnt` 출력

### 장단점

* 장점

  * set 사용으로 등장 여부 체크 O(1)
  * 논리가 직관적이고, 그룹 단어 정의와 거의 1:1 매핑된 구조
  * 시간복잡도 O(N * L)로 깔끔함

* 단점

  * 빈 문자열이 들어온다면 `s[0]`에서 에러가 날 수 있음 (문제 조건 상 빈 문자열은 없으므로 실전에서는 문제 없음)
  * `cur`와 `sett`를 별도로 관리해야 하므로, 코드가 약간 장황해 보일 수 있음

---

## 풀이 2 — 스택 리스트로 문자 순서 기록 (사용자 풀이)

```python
import sys
read = sys.stdin.readline

n = int(read())
cnt = 0
for _ in range(n):
    string = read().rstrip()
    stk = [string[0]]
    for s in string[1:]:
        if s != stk[-1]:
            if s not in stk:
                stk.append(s)
            else:
                break
    else:
        cnt += 1

print(cnt)
```

### 핵심 포인트

* `stk` 리스트에 “등장한 문자들의 순서”를 기록
* 현재 문자와 `stk[-1]`(마지막 문자)를 비교해

  * 같으면 → 같은 연속 구간, 그대로 진행
  * 다르면 → 새 문자 구간 시작

    * 이 새 문자가 `stk`에 이미 있으면 → 과거에 다른 구간에서 등장한 문자 → 그룹 단어 아님
    * 없으면 → 첫 등장 문자 → `stk.append(s)`

### 로직 설명 (중요부분만)

1. 단어 하나 읽기 후

   * `stk = [string[0]]` 로 첫 문자만 넣고 시작

2. 두 번째 문자부터 순회 (`for s in string[1:]:`)

   * `s == stk[-1]`
     → 같은 문자 연속 구간 → 그대로 진행
   * `s != stk[-1]`
     → 구간이 끊어짐

     * `s not in stk` → 처음 등장하는 문자 → `stk.append(s)`
     * `s in stk` → 이전에 나왔던 문자가 다시 나온 것 → 그룹 단어 아님 → `break`

3. `for` 루프가 `break` 없이 끝나면

   * `else:` 블록에서 `cnt += 1`

4. 모든 단어에 대해 반복 후 `cnt` 출력

### 장단점

* 장점

  * 스택(리스트)의 top(`stk[-1]`)만 비교하는 구조라, 현재 문자 추적이 간단함
  * 등장 순서를 그대로 `stk`에 담기 때문에 디버깅 시 어떤 문자들이 어떤 순서로 나왔는지를 한눈에 확인 가능

* 단점

  * `s not in stk` 체크가 리스트 탐색이라 O(L)
    → 전체적으로 최악 O(N * L^2)까지 가능 (L ≤ 100이라 괜찮긴 함)
  * set에 비해 “등장했는지 여부만” 필요한 문제에서는 다소 비효율적

---

## 풀이 3 — 방문 배열로 구현 (개선 제안)

같은 아이디어를 조금 더 “정석적인 패턴”으로 정리하면,
알파벳 26개에 대해 방문 여부를 표시하는 배열을 사용해도 됨.

```python
import sys
read = sys.stdin.readline

n = int(read())
answer = 0

for _ in range(n):
    s = read().rstrip()
    visited = [False] * 26
    prev = s[0]
    visited[ord(prev) - ord('a')] = True

    for ch in s[1:]:
        if ch != prev:
            idx = ord(ch) - ord('a')
            if visited[idx]:
                break
            visited[idx] = True
            prev = ch
        # ch == prev 인 경우는 그냥 계속 연속 구간이므로 패스
    else:
        answer += 1

print(answer)
```

### 핵심 포인트

* `visited[26]` 배열로 알파벳 등장 여부 관리
* `prev`로 이전 문자(현재 연속 구간의 문자)를 추적
* 문자가 바뀔 때만 방문 여부 체크
* 논리 구조는 풀이 1과 동일하지만, 알파벳 문제에서 자주 쓰는 패턴(배열 인덱싱) 연습용으로 좋음

### 장단점

* 장점

  * set 대신 배열을 쓰기 때문에 상수 시간도 더 작고, C/C++ 포팅 시에도 바로 쓰기 좋음
  * “알파벳 인덱싱” 패턴을 익힐 수 있음 (`ord(ch) - ord('a')`)

* 단점

  * 파이썬에서는 set이 더 가독성이 좋을 때도 있음
  * 알파벳이 아닌 문자(유니코드 등)로 확장되면 이 방식은 바로 적용하기 어려움

---

## 비슷한 문제에서의 사고과정

1. **“연속 구간 + 재등장 여부” 패턴 인지하기**

   * 어떤 값이 “한 번 등장했다가 사라진 뒤 다시 나오면 안 된다” 류의 조건이 나오면
     → “현재 값” + “등장 여부 기록” 구조를 떠올리면 됨

2. **자료구조 선택 패턴**

   * 값의 “존재 여부”만 필요 → `set` 또는 boolean 배열
   * “존재 여부 + 순서”가 필요 → 리스트, deque 등

3. **문자열을 한 번 훑으면서 조건을 만족하는지 체크**

   * 대부분 O(L) 한 번 순회로 해결됨
   * “문자가 바뀔 때만 검사” 같은 식으로 불필요한 검사를 줄이는 패턴 익히기

4. **유사 유형 예시**

   * “연속된 구간의 개수 세기”
   * “문자열에서 같은 문자가 연속해서 몇 번 나오는지 세기”
   * “연속된 숫자 구간 찾기” (이전 코테에서 언급했던 유형과도 구조적으로 비슷함)

---

## 정리 요약

* 그룹 단어 정의는
  “어떤 문자가 등장하기 시작하면, 그 문자가 끝날 때까지 중간에 다른 문자가 끼어들 수는 있지만, 끝난 뒤에 다시 나오면 안 된다”는 조건으로 요약 가능.
* 구현 패턴

  * 현재 문자(`cur` or `prev`)를 추적
  * 문자 구간이 바뀌는 지점에서만 “이 문자가 예전에 등장했는지” 확인
  * 등장 여부는 set, 리스트, 방문 배열 등으로 관리
* 사용자 풀이 1(set)과 풀이 2(리스트 스택)는 둘 다 아이디어가 정확하고, 실전에서도 충분히 통과 가능한 코드임.

  * 실전 코딩테스트에서는 풀이 1처럼 set을 사용하는 방식이 가장 무난하고,
  * C++/Java 포팅 시에는 풀이 3처럼 방문 배열 패턴으로 바꾸기 좋음.
