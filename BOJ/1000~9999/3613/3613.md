# BOJ 3613 - Java vs C++ (w/ gpt-5.1-codex)

## 문제 정보
- 요구: 변수명을 Java(camelCase) ↔ C++(snake_case)로 변환, 규칙 위반 시 Error!.
- 입출력: 한 줄 문자열 s.

## 사고 흐름
1. 사전 에러 체크: 빈 문자열, 앞/뒤 `_`, 첫 글자 대문자, `__` 포함은 즉시 Error.
2. `_`와 대문자가 동시에 있으면 혼합 규칙이므로 Error.
3. `_`가 있으면 C++→Java, 대문자가 있으면 Java→C++, 둘 다 없으면 그대로.

## 핵심 아이디어
- 플래그: `has_underscore`, `has_upper`로 입력 형식을 판정.
- C++→Java: `_`로 split 후 첫 단어 제외 나머지 앞글자를 대문자로 변경해 연결.
- Java→C++: 대문자 앞에 `_`를 삽입하고 소문자로 변환.

## 풀이 1 (전체 코드)
```python
import sys
read = sys.stdin.readline

def solution():
    s = read().rstrip()

    # 1. 기본 에러 체크
    # 비어 있으면 안 됨
    # 맨 앞/뒤에 '_' 오면 안 됨
    # 첫 글자가 대문자면 안 됨
    # 연속 '__" 이면 안 됨
    if not s or s[0] == "_" or s[-1] == "_" or s[0].isupper() or '__' in s:
        print("Error!")
        return

    has_underscore = '_' in s # c++
    has_upper = any(ch.isupper() for ch in s) # java

    # 2. c++, java 규칙 동시에 섞인 경우 는 error
    if has_underscore and has_upper:
        print("Error!")
        return

    # 3. c++ -> java 형식
    if has_underscore:
        parts = s.split('_')
        
        # parts 중에 빈 문자열이 있으면 Error
        if any(len(p) == 0 for p in parts):
            print("Error!")
            return

        res = parts[0]
        for word in parts[1:]:
            res += word[0].upper() + word[1:]
        print(res)
        return

    # 4. java -> c++ 형식
    if has_upper:
        res = []
        for ch in s:
            if ch.isupper():
                res.append('_')
                res.append(ch.lower())
            else:
                res.append(ch)
        print("".join(res))
        return
    
    # 5. 둘 다 가능한 평범한 문자 (ex abc => 그대로 abc 출력)
    print(s)

if __name__ == "__main__":
    solution()
```

## 로직 설명 (핵심 부분)
- 에러 조건을 먼저 차단해 변환 대상 형식을 확정.
- `_` 기반 분할/대문자 삽입으로 서로 다른 스타일을 변환.

## 정리 요약
- 형식 판정 플래그 + 사전 에러 체크 후 단방향 변환 수행, 혼합 규칙은 즉시 Error.***
