````markdown
# BOJ 5639 — 이진 검색 트리 (w/ chatgpt)

# 문제 요약
전위 순회 결과가 주어졌을 때, 해당 이진 검색 트리(BST)를 구성한다고 가정하고 그 트리를 **후위 순회**한 결과를 출력하는 문제.  
BST 특성(왼 < 루트 < 오른)을 활용해야 하며, 입력 크기가 최대 10,000이므로 **logN~N 수준 재귀**가 필요.

# 사고흐름
- 전위 순회는 `루트 → 왼쪽 → 오른쪽` 순.
- 후위 순회는 `왼쪽 → 오른쪽 → 루트` 순.
- 전위 순회에서 첫 값은 항상 루트.
- 그 다음부터 나오는 값 중 **root 보다 작은 구간은 왼쪽 서브트리**, 그 뒤는 모두 오른쪽 서브트리.
- 특정 구간 `[start, end)` 에 대해:
  - `root = pre[start]`
  - `left = (start+1 ~ idx-1)`
  - `right = (idx ~ end-1)`  
  여기서 `idx`는 처음으로 root보다 큰 값이 나오는 지점.

시간복잡도  
- 최악(O(N²)) 가능하지만 입력이 랜덤 트리 형태에 가깝고 N=10k여서 Python도 pass 가능.  
- C++은 더 안정적.

# 핵심아이디어
- **전위 순회 배열을 BST 규칙으로 분할하여 재귀 DFS**
- 왼쪽·오른쪽을 먼저 내려간 뒤 root 출력 → 후위 순회 완성
- start/end 인덱스 기반으로 구간 처리 → 리스트 복사 방지

---

# 풀이 1 (Python)

```python
import sys
# sys.stdin = open("in.txt", "r")
read = sys.stdin.readline
sys.setrecursionlimit(int(1e9))

pre_order = []

while True:
    try:
        pre_order.append(int(read()))
    except:
        break

def dfs(start, end):
    if start >= end:
        return

    root = pre_order[start]

    # 왼쪽 서브트리가 끝나는 지점 찾기
    idx = start + 1
    while idx < end and pre_order[idx] < root:
        idx += 1
    
    # 왼쪽
    dfs(start+1, idx)  # [start+1, idx)
    # 오른쪽
    dfs(idx, end)
    # 루트 출력
    print(root)

dfs(0, len(pre_order))
````

## 핵심 포인트

* 전위 배열의 첫 원소는 루트
* root보다 작은 값들은 왼쪽 서브트리
* root보다 큰 값이 처음 등장하는 지점을 기준으로 분할

## 로직 설명 (중요부분만)

* `idx`를 root보다 큰 첫 값까지 이동
* 좌/우 구간에 대해 dfs 재귀
* 최종적으로 root 출력 → 후위 순회 완성

## 장단점

### 장점

* 메모리 복사 없음
* 직관적이고 BST 규칙 활용 명확

### 단점

* 입력이 정렬된 경우 O(N²) 발생 가능
* Python은 recursionlimit 설정 필요

---

# 풀이 2 (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> pre_order;

void dfs(int start, int end){
    if (start >= end) return;

    int root = pre_order[start];

    // 왼쪽 서브트리가 끝나는 지점 찾기
    int idx = start + 1;
    while (idx < end && pre_order[idx] < root) {
        idx++;
    }

    // 왼쪽
    dfs(start+1, idx);
    // 오른쪽
    dfs(idx, end);
    // 루트 출력
    cout << root << "\n";    
}

int main() {
    // freopen("in.txt", "r", stdin);

    int x;
    while (cin >> x) {
        pre_order.push_back(x);
    }

    dfs(0, pre_order.size());

    return 0;
}
```

## 핵심 포인트

* Python과 동일한 분할 로직
* 후위 순회 규칙에 맞춰 root를 마지막에 출력

## 로직 설명 (중요부분만)

* 구간 `[start, end)`만 재귀적으로 쪼갬
* 왼쪽 → 오른쪽 → 루트 순서로 출력

## 장단점

### 장점

* C++에서는 스택 안정적 → 시간 초과/메모리 문제 적음
* 전체적인 실행속도 우수

### 단점

* 최악 O(N²) 가능성 존재하지만 실제 입력에서는 크게 문제되지 않음

---

# 비슷한 문제에서의 사고과정

* 전위/중위/후위 순회 조합으로 트리 복원 문제 → 핵심은 **서브트리 경계 찾기**
* BST는 “root 기준으로 왼쪽 < root < 오른쪽” 규칙이 강력한 힌트
* 슬라이싱 대신 **인덱스 기반 구간 처리**가 정석 패턴

---

# 정리 요약

* 전위 순회 첫 값은 루트
* root 기준으로 작은 연속 구간은 왼쪽 서브트리
* 이후 값들은 오른쪽 서브트리
* DFS로 왼쪽·오른쪽 먼저 방문 후 root 출력 → 후위 순회 완성
* 인덱스로 처리해 메모리/시간 모두 효율화

