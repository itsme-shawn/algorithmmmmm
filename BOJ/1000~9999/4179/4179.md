# BOJ 4179 - 불! (w/ gpt-5.1-codex)
(G3) <https://www.acmicpc.net/problem/4179>

## 문제 정보
- 요구: 불 확산 시간표와 사람 이동을 분리 계산해 탈출 최소 시간을 구하기, 불보다 먼저 갈 수 없으면 IMPOSSIBLE.
- 입출력: R, C, 보드(., #, J, F).

## 사고 흐름
1. 불은 여러 시작점 → 다중 BFS로 각 칸의 불 도착 시간을 먼저 계산.
2. 사람 BFS에서 다음 칸 이동 시 `인간시간+1 < 불시간` 조건으로만 이동.
3. 가장자리에 도달하면 즉시 결과 출력, 실패 시 IMPOSSIBLE.

## 핵심 아이디어
- `fire_visited`, `human_visited`를 시간 배열로 두고 초기값을 inf로 설정.
- 시작이 이미 가장자리면 1로 종료.
- 불보다 늦게 도착하거나 벽/불인 칸은 건너뛴다.

## 풀이 1 (내 코드)
```python
import sys
from collections import deque

# sys.stdin = open("in.txt", "r")
read = sys.stdin.readline

r, c = map(int, read().split())
board = [list(read().rstrip()) for _ in range(r)]

def pprint(arr):
    print("===")
    for row in arr:
        print(row)
    print("===")


dx = [-1,0,1,0]
dy = [0,1,0,-1]

# pprint(board)

fire_q = deque()
fire_visited = [[float('INF')]*c for _ in range(r)]

human_q = deque()
human_visited = [[float('INF')]*c for _ in range(r)]

for i in range(r):
    for j in range(c):
        if board[i][j] == "J":
            human_q.append((i,j))
            human_visited[i][j] = 0
            # 끝지점 예외처리 종료
            if i ==0 or i == r-1 or j == 0 or j == c-1:
                print(1)
                exit(0)
        elif board[i][j] == "F":
            fire_q.append((i,j)) # 다중 시작점 처리
            fire_visited[i][j] = 0

# print("init fire")
# pprint(fire_visited)

# print("init human")
# pprint(human_visited)

while fire_q:
    (x,y) = fire_q.popleft()
    # print("+++")
    # print("x: ", x, "y : ", y)
    # pprint(fire_visited)
    
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if 0<=nx<r and 0<=ny<c and fire_visited[nx][ny] == float('inf') and board[nx][ny] == ".":
            fire_visited[nx][ny] = fire_visited[x][y] + 1
            fire_q.append((nx,ny))

while human_q:
    (x,y) = human_q.popleft()
    # print("---")
    # print("x: ", x, "y : ", y)
    # pprint(human_visited)
    
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if 0<=nx<r and 0<=ny<c and human_visited[nx][ny] == float('inf') and board[nx][ny] == "." and human_visited[x][y]+1<fire_visited[nx][ny]:
            human_visited[nx][ny] = human_visited[x][y] + 1
            if nx == 0 or nx == r-1 or ny == 0 or ny == c-1: # 종료
                result = human_visited[nx][ny] + 1
                print(result)
                exit(0)
            human_q.append((nx,ny))


# print("after fire")
# pprint(fire_visited)

# print("after human")
# pprint(human_visited)

print("IMPOSSIBLE")
```

## 로직 설명 (핵심 부분)
- 불 BFS로 각 칸의 도달 시간을 선계산.
- 사람 BFS는 “다음 시간 < 불 도착 시간” 조건을 만족하는 칸만 이동, 가장자리에 닿으면 그 시점+1이 답.

## 내 풀이 피드백
- 불 퍼짐을 `board == "."`으로만 제한해 시작 지점 `J`에는 불이 절대 도달하지 않는 모순이 있음(실제는 빈칸과 동일하게 불에 타야 함). `board != "#"`로 체크해도 로직은 유지되고 정확도가 올라감.
- `float('INF')`와 `float('inf')`는 같지만, 가독성을 위해 상수 `INF = 10**9` 등으로 두고 일관되게 쓰면 조건식이 명확해짐.
- 디버그 코드가 주석으로 남아 있어 제출용/학습용 구분 시 정리하면 좋음.

## 풀이 2 — AI 제안 (불/사람 분리 BFS, 칸 종류 무시)
```python
import sys
from collections import deque

input = sys.stdin.readline
INF = 10 ** 9

r, c = map(int, input().split())
grid = [list(input().strip()) for _ in range(r)]

fire = [[INF] * c for _ in range(r)]
human = [[INF] * c for _ in range(r)]
fq, hq = deque(), deque()

for i in range(r):
    for j in range(c):
        if grid[i][j] == "F":
            fire[i][j] = 0
            fq.append((i, j))
        elif grid[i][j] == "J":
            human[i][j] = 0
            hq.append((i, j))
            # 이미 가장자리면 1초 탈출
            if i == 0 or i == r - 1 or j == 0 or j == c - 1:
                print(1)
                sys.exit(0)

dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# 1) 불 도착 시간 계산
while fq:
    x, y = fq.popleft()
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        if 0 <= nx < r and 0 <= ny < c and grid[nx][ny] != "#" and fire[nx][ny] == INF:
            fire[nx][ny] = fire[x][y] + 1
            fq.append((nx, ny))

# 2) 사람 이동
while hq:
    x, y = hq.popleft()
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        if 0 <= nx < r and 0 <= ny < c and grid[nx][ny] != "#" and human[nx][ny] == INF:
            nt = human[x][y] + 1
            if nt < fire[nx][ny]:
                human[nx][ny] = nt
                if nx == 0 or nx == r - 1 or ny == 0 or ny == c - 1:
                    print(nt + 1)
                    sys.exit(0)
                hq.append((nx, ny))

print("IMPOSSIBLE")
```
- 불 BFS는 벽(`'#'`)만 피하고 나머지는 전부 연소 가능하게 처리해 시작 지점도 불 도달 시간에 포함.
- 사람 BFS는 불 시간표보다 “엄격히 빠른” 칸만 이동해 안전 보장.
- 시간복잡도 `O(RC)`, 추가 메모리 `O(RC)`.

## 정리 요약
- 불/사람을 분리한 이중 BFS로 탈출 가능 여부를 판정, 불보다 늦게 도달하는 경로는 전부 제거.***
