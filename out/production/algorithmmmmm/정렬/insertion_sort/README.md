- 📅 Date: 2020-11-29 (일)

# 삽입 정렬 (Insertion Sort)

## 📝 개념

* 손안의 카드를 정렬하는 방법과 유사하다.  
    * 새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리를 찾아 삽입한다.  
    * 새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다. 

* 자료 배열의 모든 요소를 **앞에서부터 차례대로 이미 정렬된 배열 부분과 비교**하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘  

* 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.

### 삽입정렬의 구체적인 로직

* 삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.  

* 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다.   자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.  

* 처음 Key 값은 **두 번째 자료부터** 시작한다.

### 삽입정렬 특징

* 버블/선택정렬은 외부 루프가 거듭될 수록 탐색 범위가 줄어드는 반면에 삽입 정렬은 오히려 점점 정렬 범위가 넓어진다.

* 큰 그림에서 보았을 때 외부 루프는 순방향, 내부 루프는 역방향으로 진행한다.

<br>

 ![삽입정렬](./insertion_sort.png "insertion-sort")
<br>

## 📝 예제


* 문제  
배열에 7, 4, 5, 1, 3이 저장되어 있다고 가정하고 자료를 오름차순으로 정렬해 보자.


* 입력  
[7,4,5,3,1]


* 출력  
[1,3,4,5,7]

<br>

## 💡 풀이1

### Solved code

(Important part only)
``` python
def insertion_sort(list) : 
  for i in range(1, len(list)) : # 외부 루프 : key 값 지정 (순방향)
    for j in range(i, 0, -1) : # 내부 루프 : key 값과 앞의 인덱스를 비교하면서 SWAP
      if( list[j] < list[j-1]) : 
        list[j-1], list[j] = list[j], list[j-1]
  return list

print(insertion_sort([7,4,5,3,1]))
```

### Solution

- 외부 루프는 key 값을 정해주는 루프로 (n-1) 번 시행된다. (1번 인덱스부터)
- 내부 루프에서는 key 값과 바로 앞의 인덱스 원소와 비교하면서 key 값이 더 작을 시, SWAP 한다.

### Commentary

파이썬 for 문에서 `for i in range(10, 0, -1)` 처럼 증감폭을 지정해서 변수를 감소시키면서 반복문을 돌릴 수 있다. 위의 예시는 `i=10` 부터 `i=1` 까지 돌게 된다.

<br>

## 💡 풀이2 (풀이1 개선)

### Solved code

(Important part only)
``` python
def insertion_sort(arr):
  for end in range(1, len(arr)):
    i = end
    while i > 0 and arr[i - 1] > arr[i]:
      arr[i - 1], arr[i] = arr[i], arr[i - 1]
      i -= 1
  return arr

print(insertion_sort([7,4,5,3,1]))

```

### Solution

- 풀이1 을 개선한 코드로, 삽입 정렬에서 key 값의 왼쪽 배열들은 다 정렬이 완료된 상태이므로, key 값을 기준으로 왼쪽으로 탐색하다가 최초로 key 보다 작은 값을 만나면 while 루프를 종료시킨다.

- 예를 들면, 기존 정렬 범위 [1, 2, 3, 5] 에 4가 새롭게 추가된다면, 5는 4보다 크기 때문에 swap이 필요하지만, 3은 4보다 작기 때문에 swap이 필요없다. 그리고 3보다 앞에 있는 숫자들은 기존 패스에서 이미 정렬을 해놓았기 때문에 당연히 3보다는 작을 것이며, 더 이상의 4와 대소 비교는 무의미하다.

<br>

## 💡 풀이3 (풀이2 개선)

### Solved code

(Important part only)
``` python
def insertion_sort(arr):
  for key_idx in range(1, len(arr)):
    to_insert = arr[key_idx]
    i = key_idx
    while i > 0 and arr[i - 1] > to_insert:
      arr[i] = arr[i - 1]
      i -= 1
    arr[i] = to_insert
  return arr

print(insertion_sort([7,4,5,3,1]))
```

### Solution

- swap 작업없이 단순히 값들을 shift 시키는 것만으로도 삽입 정렬의 구현이 가능합니다. 앞의 값이 정렬 범위에 추가시킨 값보다 클 경우 앞의 값을 뒤로 밀다가 최초로 작은 값을 만나는 순간 그 뒤에 추가된 값을 꼽으면 된다.

- `to_insert` 라는 변수에 key 값을 미리 저장해놓고 내부루프에서 key 값과 바로 앞 인덱스 원소를 비교를 하되, 이번에는 SWAP 을 하지않고 오른쪽으로 땡기기만 한다. 그 다음 내부루프가 끝나면 빈 자리에 key 값을 넣어주면 된다.

<br>

## 정리

* 장점 
  * 안정한 정렬 방법
  * 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
  * 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.  

* 단점
  * 비교적 많은 레코드들의 이동을 포함한다.
  * 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.




<br>

## ⏳ 시간복잡도 (풀이3 기준)

<h4>최선의 경우(Best case) : 자료가 이미 정렬되있는 경우</h4> 

- 외부 루프 : (n-1)번
- 내부 루프(비교 후 shift) : 실행 X

  **총 소요 시간 : (n-1)**

<h4>최악의 경우(Worst case) : 입력자료가 역순인 경우</h4> 

- 외부 루프 : (n-1)번
- 내부 루프(비교 후 shift) : 처음 외부 루프에서 1회 , 두 번째 외부 루프에서 2회, ... n-1 번째 외부 루프에서 n-1회 = n(n-1) / 2
- 자리 교환 : 외부 루프의 시행순번을 k 라고 하면 모든 외부 루프당 (k+1) 번 일어남

  **총 소요 시간 : n(n-1) / 2 + n(k+1)**

따라서 시간복잡도는  
- 최선 : **O(n)**
- 최악 : **O(n^2)**    

시간복잡도는 최악일 때를 기준으로 하므로 삽입정렬의 시간복잡도는 **O(n^2)** 이다.

### References
- [[알고리즘] 삽입 정렬(insertion sort)이란](https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html)
- [[알고리즘] 삽입 정렬 - Insertion Sort (Python, Java)](https://www.daleseo.com/sort-insertion/)
